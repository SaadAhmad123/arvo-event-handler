<!DOCTYPE html><html class="default" lang="en" data-base="../"><head><meta charset="utf-8"/><meta http-equiv="x-ua-compatible" content="IE=edge"/><title>ArvoResumable | arvo-event-handler</title><meta name="description" content="Documentation for arvo-event-handler"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="../assets/style.css"/><link rel="stylesheet" href="../assets/highlight.css"/><script defer src="../assets/main.js"></script><script async src="../assets/icons.js" id="tsd-icons-script"></script><script async src="../assets/search.js" id="tsd-search-script"></script><script async src="../assets/navigation.js" id="tsd-nav-script"></script><script async src="../assets/hierarchy.js" id="tsd-hierarchy-script"></script><link rel="stylesheet" href="../assets/typedoc-github-style.css"/></head><body><script>document.documentElement.dataset.theme = localStorage.getItem("tsd-theme") || "os";document.body.style.display="none";setTimeout(() => window.app?app.showPage():document.body.style.removeProperty("display"),500)</script><header class="tsd-page-toolbar"><div class="tsd-toolbar-contents container"><a href="../index.html" class="title">arvo-event-handler</a><div id="tsd-toolbar-links"></div><button id="tsd-search-trigger" class="tsd-widget" aria-label="theme_search"><svg width="16" height="16" viewBox="0 0 16 16" fill="none" aria-hidden="true"><use href="../assets/icons.svg#icon-search"></use></svg></button><dialog id="tsd-search" aria-label="theme_search"><input role="combobox" id="tsd-search-input" aria-controls="tsd-search-results" aria-autocomplete="list" aria-expanded="true" autocapitalize="off" autocomplete="off" placeholder="theme_search_placeholder" maxLength="100"/><ul role="listbox" id="tsd-search-results"></ul><div id="tsd-search-status" aria-live="polite" aria-atomic="true"><div>theme_preparing_search_index</div></div></dialog><a href="#" class="tsd-widget menu" id="tsd-toolbar-menu-trigger" data-toggle="menu" aria-label="theme_menu"><svg width="16" height="16" viewBox="0 0 16 16" fill="none" aria-hidden="true"><use href="../assets/icons.svg#icon-menu"></use></svg></a></div></header><div class="container container-main"><div class="col-content"><div class="tsd-page-title"><ul class="tsd-breadcrumb" aria-label="Breadcrumb"><li><a href="" aria-current="page">ArvoResumable</a></li></ul></div><div class="tsd-panel tsd-typography"><blockquote>
<p>Really bad temporary documentation by GenAI (Claude). Will update manually later. Sorry...</p>
</blockquote>
<h1 id="arvoresumable" class="tsd-anchor-link">ArvoResumable<a href="#arvoresumable" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h1><p>A stateful orchestration handler for managing distributed workflows in the Arvo event-driven system. ArvoResumable provides a handler-based approach to workflow orchestration that prioritizes explicit control and simplicity over declarative abstractions.</p>
<h2 id="overview" class="tsd-anchor-link">Overview<a href="#overview" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>ArvoResumable addresses fundamental challenges in event-driven architecture by providing a straightforward imperative programming model for workflow orchestration. Unlike state machine approaches, it uses handler functions that give developers direct control over workflow logic, making debugging easier and reducing the learning curve for teams familiar with traditional programming patterns.</p>
<h3 id="key-capabilities" class="tsd-anchor-link">Key Capabilities<a href="#key-capabilities" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><ul>
<li><strong>Handler-based workflow orchestration</strong> with explicit state control</li>
<li><strong>Contract-driven event validation</strong> with runtime schema enforcement</li>
<li><strong>Distributed resource locking</strong> for transaction safety</li>
<li><strong>Comprehensive OpenTelemetry integration</strong> for observability</li>
<li><strong>Automatic error handling</strong> with system error event generation</li>
<li><strong>Support for orchestrator chaining</strong> and nested workflow patterns</li>
<li><strong>Multi-domain event routing</strong> and organization</li>
<li><strong>Graduated complexity</strong> allowing simple workflows to remain simple</li>
</ul>
<h2 id="getting-started" class="tsd-anchor-link">Getting Started<a href="#getting-started" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><h3 id="basic-setup" class="tsd-anchor-link">Basic Setup<a href="#basic-setup" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><pre><code class="typescript">import { createArvoResumable, SimpleMachineMemory } from 'arvo-xstate';
import { createArvoOrchestratorContract, createArvoContract } from 'arvo-core';
import { z } from 'zod';

// Define your orchestrator contract
const userProcessingContract = createArvoOrchestratorContract({
  uri: '#/orchestrators/userprocessing',
  type: 'com.user.processing',
  versions: {
    '1.0.0': {
      init: z.object({
        userId: z.string(),
        action: z.enum(['create', 'update', 'delete'])
      }),
      complete: z.object({
        success: z.boolean(),
        message: z.string()
      })
    }
  }
});

// Define service contracts
const validationService = createArvoContract({
  uri: '#/services/validation',
  type: 'com.validation.check',
  versions: {
    '1.0.0': {
      accepts: z.object({
        userId: z.string(),
        data: z.any()
      }),
      emits: {
        'evt.validation.success': z.object({
          valid: z.boolean(),
          issues: z.array(z.string()).optional()
        })
      }
    }
  }
});

// Create the orchestrator
const orchestrator = createArvoResumable({
  contracts: {
    self: userProcessingContract.version('1.0.0'),
    services: {
      validation: validationService.version('1.0.0')
    }
  },
  memory: new SimpleMachineMemory(),
  executionunits: 1,
  handler: {
    '1.0.0': async ({ context, input, service, contracts }) => {
      // Handle initialization
      if (input) {
        return {
          context: {
            userId: input.data.userId,
            action: input.data.action,
            step: 'validating'
          },
          services: [{
            type: 'com.validation.check',
            data: {
              userId: input.data.userId,
              data: input.data
            }
          }]
        };
      }

      // Handle service responses
      if (service?.type === 'evt.validation.success') {
        if (service.data.valid) {
          return {
            context: { ...context, step: 'completed' },
            output: {
              success: true,
              message: 'User processing completed successfully'
            }
          };
        } else {
          return {
            output: {
              success: false,
              message: `Validation failed: ${service.data.issues?.join(', ')}`
            }
          };
        }
      }
    }
  }
});

// Execute workflow
const result = await orchestrator.execute(initializationEvent);
</code><button type="button">Copy</button></pre>

<h2 id="multi-domain-event-broadcasting" class="tsd-anchor-link">Multi-Domain Event Broadcasting<a href="#multi-domain-event-broadcasting" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>ArvoResumable supports sophisticated multi-domain event distribution, enabling advanced workflow patterns including human-in-the-loop operations, external system integrations, and custom processing pipelines.</p>
<h3 id="understanding-domains" class="tsd-anchor-link">Understanding Domains<a href="#understanding-domains" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>Domains represent different processing contexts or routing namespaces for events. They enable sophisticated event distribution patterns where a single handler response can create multiple events for different processing pipelines.</p>
<h3 id="domain-assignment-rules" class="tsd-anchor-link">Domain Assignment Rules<a href="#domain-assignment-rules" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>When returning events from a handler, you can specify domains using the <code>domain</code> field:</p>
<ol>
<li><strong>Array Processing</strong>: Each element in the <code>domain</code> array creates a separate ArvoEvent instance</li>
<li><strong><code>undefined</code> in Array Resolution</strong>: <code>undefined</code> elements resolve to: <code>event.contract.domain ?? triggeringEvent.domain ?? handler.contract.domain ?? null</code></li>
<li><strong><code>null</code> in Array Resolution</strong>: <code>null</code> elements resolve to events which <code>domain: null</code></li>
<li><strong>Automatic Deduplication</strong>: Duplicate domains are automatically removed to prevent redundant events</li>
<li><strong>Default Behavior</strong>: Omitting the <code>domain</code> field (or setting to <code>undefined</code>) defaults to <code>[null]</code> (single event, no domain)</li>
</ol>
<h3 id="domain-broadcasting-patterns" class="tsd-anchor-link">Domain Broadcasting Patterns<a href="#domain-broadcasting-patterns" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><pre><code class="typescript">handler: {
  '1.0.0': async ({ context, input, service }) => {
    if (input) {
      return {
        context: { userId: input.data.userId },
        services: [
          // Standard internal processing
          {
            type: 'com.validation.check',
            data: { userId: input.data.userId }
          },
          
          // External system integration  
          {
            domain: ['external'],
            type: 'com.approval.request',
            data: { 
              userId: input.data.userId,
              requiresApproval: true 
            }
          },
          
          // Multi-domain event for parallel processing
          {
            domain: ['analytics', 'audit', null],
            type: 'com.user.action.logged',
            data: { 
              action: 'user_processing_started',
              userId: input.data.userId 
            }
          }
        ]
      };
    }
  }
}
</code><button type="button">Copy</button></pre>

<h3 id="error-broadcasting" class="tsd-anchor-link">Error Broadcasting<a href="#error-broadcasting" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>System errors are automatically broadcast to all relevant processing contexts:</p>
<ul>
<li>Source event domain (<code>event.domain</code>)</li>
<li>Handler contract domain (<code>handler.contract.domain</code>)</li>
<li>No-domain context (<code>null</code>)</li>
</ul>
<p>Duplicates are automatically removed, so if <code>event.domain === handler.contract.domain</code>, only two error events are created instead of three.</p>
<h2 id="handler-function-architecture" class="tsd-anchor-link">Handler Function Architecture<a href="#handler-function-architecture" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><h3 id="handler-signature" class="tsd-anchor-link">Handler Signature<a href="#handler-signature" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>Each version in your contract maps to a handler function with this signature:</p>
<pre><code class="typescript">async ({ 
  span,           // OpenTelemetry span for tracing
  metadata,       // Complete workflow metadata (null for new workflows)
  collectedEvents,// Type-safe map of collected service events
  context,        // Current workflow state (null for new workflows)
  input,          // Initialization event data (only for start events)
  service,        // Service response event data (only for callbacks)
  contracts       // Available contracts for validation
}) => {
  // Handler logic here
  return {
    context?: any,    // Updated workflow state
    output?: any,     // Completion data (terminates workflow)
    services?: any[]  // Service invocation events
  };
}
</code><button type="button">Copy</button></pre>

<h3 id="handler-parameters" class="tsd-anchor-link">Handler Parameters<a href="#handler-parameters" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><ul>
<li><strong><code>span</code></strong>: OpenTelemetry span for distributed tracing and logging</li>
<li><strong><code>metadata</code></strong>: Complete workflow metadata including status, subject, event tracking</li>
<li><strong><code>collectedEvents</code></strong>: Type-safe access to events collected from previous service calls</li>
<li><strong><code>context</code></strong>: Your workflow's custom state data</li>
<li><strong><code>input</code></strong>: Present only for initialization events (workflow start)</li>
<li><strong><code>service</code></strong>: Present only for service response events (callbacks)</li>
<li><strong><code>contracts</code></strong>: Contract definitions for type validation and event creation</li>
</ul>
<h3 id="return-values" class="tsd-anchor-link">Return Values<a href="#return-values" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><ul>
<li><strong><code>context</code></strong>: Updated workflow state to persist (merged with existing state)</li>
<li><strong><code>output</code></strong>: Completion event data that terminates the workflow</li>
<li><strong><code>services</code></strong>: Array of service invocation events to emit</li>
</ul>
<h2 id="event-collection-and-processing" class="tsd-anchor-link">Event Collection and Processing<a href="#event-collection-and-processing" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>ArvoResumable automatically collects service response events and makes them available through the <code>collectedEvents</code> parameter:</p>
<pre><code class="typescript">handler: {
  '1.0.0': async ({ collectedEvents, context }) => {
    // Access collected events by type with full type safety
    const validationEvents = collectedEvents['evt.validation.success'] || [];
    const approvalEvents = collectedEvents['evt.approval.completed'] || [];
    
    // Process collected events
    const allValidationsComplete = validationEvents.length >= context.expectedValidations;
    const hasApproval = approvalEvents.some(event => event.data.approved);
    
    if (allValidationsComplete && hasApproval) {
      return {
        output: {
          success: true,
          message: 'All requirements met'
        }
      };
    }
    
    // Continue waiting for more events
    return { context };
  }
}
</code><button type="button">Copy</button></pre>

<h2 id="workflow-lifecycle-management" class="tsd-anchor-link">Workflow Lifecycle Management<a href="#workflow-lifecycle-management" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><h3 id="status-management" class="tsd-anchor-link">Status Management<a href="#status-management" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>ArvoResumable automatically manages workflow status:</p>
<ul>
<li><strong><code>active</code></strong>: Workflow can accept and process events</li>
<li><strong><code>done</code></strong>: Workflow has completed and will ignore additional events</li>
</ul>
<pre><code class="typescript">handler: {
  '1.0.0': async ({ metadata, input, service }) => {
    // Check current status
    if (metadata?.status === 'done') {
      // This won't happen as the orchestrator filters these out
      return;
    }
    
    // Return output to complete workflow (sets status to 'done')
    if (shouldComplete) {
      return {
        output: { result: 'completed' }
      };
    }
    
    // Continue workflow (keeps status as 'active')
    return {
      context: updatedState,
      services: [/* more service calls */]
    };
  }
}
</code><button type="button">Copy</button></pre>

<h3 id="event-tracking" class="tsd-anchor-link">Event Tracking<a href="#event-tracking" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>The orchestrator automatically tracks:</p>
<ul>
<li><strong>Consumed events</strong>: Last event processed by the workflow</li>
<li><strong>Produced events</strong>: Events emitted in the last execution</li>
<li><strong>Expected events</strong>: Events anticipated from service calls</li>
</ul>
<pre><code class="typescript">handler: {
  '1.0.0': async ({ metadata }) => {
    // Access event history
    const lastConsumed = metadata?.events.consumed;
    const lastProduced = metadata?.events.produced;
    const expectedEvents = metadata?.events.expected;
    
    console.log(`Last event: ${lastConsumed?.type}`);
    console.log(`Produced ${lastProduced?.length} events last time`);
    console.log(`Expecting responses for ${Object.keys(expectedEvents || {}).length} events`);
  }
}
</code><button type="button">Copy</button></pre>

<h2 id="parent-child-orchestration-relationships" class="tsd-anchor-link">Parent-Child Orchestration Relationships<a href="#parent-child-orchestration-relationships" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>ArvoResumable supports hierarchical workflow execution through parent-child orchestration patterns.</p>
<h3 id="creating-child-orchestrations" class="tsd-anchor-link">Creating Child Orchestrations<a href="#creating-child-orchestrations" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><pre><code class="typescript">handler: {
  '1.0.0': async ({ input, context }) => {
    if (input?.data.requiresSubWorkflow) {
      return {
        context: { ...context, waitingForChild: true },
        services: [{
          type: 'com.child.orchestrator',
          data: {
            parentSubject$$: context.currentSubject, // Pass parent context
            childData: input.data.childRequirements
          },
          // Child might run in different domain
          domain: ['processing.child']
        }]
      };
    }
  }
}
</code><button type="button">Copy</button></pre>

<h3 id="handling-child-completion" class="tsd-anchor-link">Handling Child Completion<a href="#handling-child-completion" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>When child orchestrators complete, their completion events are automatically routed back to the parent's domain context:</p>
<pre><code class="typescript">handler: {
  '1.0.0': async ({ service, context }) => {
    // Handle child orchestrator completion
    if (service?.type === 'evt.child.orchestrator.complete') {
      return {
        context: { 
          ...context, 
          childResult: service.data,
          waitingForChild: false 
        },
        output: {
          success: true,
          childResults: service.data
        }
      };
    }
  }
}
</code><button type="button">Copy</button></pre>

<h3 id="domain-context-in-parent-child-relationships" class="tsd-anchor-link">Domain Context in Parent-Child Relationships<a href="#domain-context-in-parent-child-relationships" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><ul>
<li><strong>Parent orchestrator</strong> operates in one domain (e.g., <code>'internal'</code>)</li>
<li><strong>Child orchestrator</strong> might operate in a different domain (e.g., <code>'external'</code>)</li>
<li>When the child completes, its completion event is routed back to the <strong>parent's domain context</strong></li>
<li>Each orchestrator can operate in its own domain regardless of parent-child relationship</li>
</ul>
<h2 id="advanced-patterns" class="tsd-anchor-link">Advanced Patterns<a href="#advanced-patterns" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><h3 id="conditional-workflow-branching" class="tsd-anchor-link">Conditional Workflow Branching<a href="#conditional-workflow-branching" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><pre><code class="typescript">handler: {
  '1.0.0': async ({ input, service, context }) => {
    if (input) {
      // Branch based on input data
      if (input.data.priority === 'high') {
        return {
          context: { ...input.data, fastTrack: true },
          services: [{
            type: 'com.priority.processor',
            data: input.data
          }]
        };
      } else {
        return {
          context: { ...input.data, fastTrack: false },
          services: [{
            type: 'com.standard.processor', 
            data: input.data
          }]
        };
      }
    }
  }
}
</code><button type="button">Copy</button></pre>

<h3 id="event-aggregation" class="tsd-anchor-link">Event Aggregation<a href="#event-aggregation" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><pre><code class="typescript">handler: {
  '1.0.0': async ({ collectedEvents, context }) => {
    const approvals = collectedEvents['evt.approval.response'] || [];
    const validations = collectedEvents['evt.validation.complete'] || [];
    
    // Wait for all required approvals
    const requiredApprovals = context.approvers?.length || 0;
    const approvedCount = approvals.filter(a => a.data.approved).length;
    
    if (approvedCount >= requiredApprovals && validations.length > 0) {
      return {
        output: {
          approved: true,
          approvers: approvals.map(a => a.data.approver)
        }
      };
    }
    
    // Still waiting for more approvals
    return { context };
  }
}
</code><button type="button">Copy</button></pre>

<h3 id="human-in-the-loop-workflows" class="tsd-anchor-link">Human-in-the-Loop Workflows<a href="#human-in-the-loop-workflows" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><pre><code class="typescript">handler: {
  '1.0.0': async ({ input, service, context }) => {
    if (input && input.data.requiresHumanApproval) {
      return {
        context: { ...input.data, awaitingApproval: true },
        services: [{
          // Route to external approval system
          domain: ['external.approval'],
          type: 'com.human.approval.request',
          data: {
            requestId: input.data.id,
            description: input.data.description,
            urgency: input.data.priority
          }
        }]
      };
    }
    
    if (service?.type === 'evt.human.approval.response') {
      if (service.data.approved) {
        return {
          context: { ...context, approved: true },
          output: {
            success: true,
            approvedBy: service.data.approver
          }
        };
      } else {
        return {
          output: {
            success: false,
            reason: service.data.reason
          }
        };
      }
    }
  }
}
</code><button type="button">Copy</button></pre>

<h2 id="error-handling-philosophy" class="tsd-anchor-link">Error Handling Philosophy<a href="#error-handling-philosophy" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>ArvoResumable implements a dual-layered error handling strategy:</p>
<h3 id="transaction-errors-vs-system-error-events" class="tsd-anchor-link">Transaction Errors vs System Error Events<a href="#transaction-errors-vs-system-error-events" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p><strong>Transaction Errors</strong> (<code>TransactionViolation</code>) represent critical infrastructure failures that prevent the orchestrator from maintaining core guarantees:</p>
<ul>
<li>Lock acquisition failures</li>
<li>State persistence errors</li>
<li>Event subject validation failures</li>
</ul>
<p>These errors immediately halt execution and are thrown upward for infrastructure-level handling.</p>
<p><strong>System Error Events</strong> represent workflow-level failures during normal business operations:</p>
<ul>
<li>Invalid event data</li>
<li>Contract violations</li>
<li>Handler execution failures</li>
</ul>
<p>These become part of the normal event flow, allowing workflows to implement recovery mechanisms.</p>
<h3 id="error-handling-in-practice" class="tsd-anchor-link">Error Handling in Practice<a href="#error-handling-in-practice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><pre><code class="typescript">// Transaction errors are thrown and must be caught by infrastructure
try {
  const result = await orchestrator.execute(event);
  // Process successful result
} catch (error) {
  if (error instanceof TransactionViolation) {
    // Handle infrastructure failure
    logger.error('Infrastructure error:', error.cause);
    // Implement retry logic or alert operations
  }
  // Other violations bubble up for system handling
}

// System errors become events that can be handled in workflows
handler: {
  '1.0.0': async ({ service }) => {
    if (service?.type === 'sys.validation.error') {
      // Handle service failure gracefully
      return {
        output: {
          success: false,
          error: 'Validation service unavailable'
        }
      };
    }
  }
}
</code><button type="button">Copy</button></pre>

<h2 id="resource-locking-and-concurrency" class="tsd-anchor-link">Resource Locking and Concurrency<a href="#resource-locking-and-concurrency" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>ArvoResumable provides distributed resource locking to ensure workflow safety:</p>
<h3 id="automatic-locking-strategy" class="tsd-anchor-link">Automatic Locking Strategy<a href="#automatic-locking-strategy" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><ul>
<li><strong>Single service</strong>: Locking disabled by default (sequential execution)</li>
<li><strong>Multiple services</strong>: Locking enabled by default (potential concurrency)</li>
<li><strong>Manual override</strong>: Specify <code>requiresResourceLocking</code> explicitly</li>
</ul>
<pre><code class="typescript">const orchestrator = createArvoResumable({
  // ... other config
  requiresResourceLocking: true, // Force locking even for single service
  handler: {
    '1.0.0': async ({ context }) => {
      // Critical section protected by distributed lock
      return {
        context: { ...context, criticalUpdate: Date.now() }
      };
    }
  }
});
</code><button type="button">Copy</button></pre>

<h3 id="lock-acquisition-behavior" class="tsd-anchor-link">Lock Acquisition Behavior<a href="#lock-acquisition-behavior" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><ul>
<li>Exclusive locks prevent concurrent workflow execution</li>
<li>Lock failures trigger <code>TransactionViolation</code> errors</li>
<li>Locks are automatically released after execution completes</li>
<li>Failed lock acquisition indicates resource contention</li>
</ul>
<h2 id="observability-and-monitoring" class="tsd-anchor-link">Observability and Monitoring<a href="#observability-and-monitoring" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><h3 id="opentelemetry-integration" class="tsd-anchor-link">OpenTelemetry Integration<a href="#opentelemetry-integration" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>ArvoResumable provides comprehensive tracing through OpenTelemetry:</p>
<pre><code class="typescript">handler: {
  '1.0.0': async ({ span, input }) => {
    // Add custom span attributes
    span.setAttribute('workflow.user_id', input?.data.userId);
    span.setAttribute('workflow.priority', input?.data.priority);
    
    // Log workflow progress
    logToSpan({
      level: 'INFO',
      message: `Processing user ${input?.data.userId}`
    }, span);
    
    return {
      context: { userId: input?.data.userId },
      services: [{ /* service call */ }]
    };
  }
}
</code><button type="button">Copy</button></pre>

<h3 id="performance-monitoring" class="tsd-anchor-link">Performance Monitoring<a href="#performance-monitoring" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>Key metrics automatically tracked:</p>
<ul>
<li>Lock acquisition timing</li>
<li>Handler execution duration</li>
<li>Event processing latency</li>
<li>State persistence performance</li>
<li>Resource utilization patterns</li>
</ul>
<h2 id="testing-arvoresumable-workflows" class="tsd-anchor-link">Testing ArvoResumable Workflows<a href="#testing-arvoresumable-workflows" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><h3 id="unit-testing-handlers" class="tsd-anchor-link">Unit Testing Handlers<a href="#unit-testing-handlers" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><pre><code class="typescript">import { describe, it, expect } from 'vitest';

describe('UserProcessingHandler', () => {
  it('should handle initialization correctly', async () => {
    const handler = userProcessingHandler['1.0.0'];
    
    const result = await handler({
      span: mockSpan,
      metadata: null,
      collectedEvents: {},
      context: null,
      input: {
        type: 'com.user.processing',
        data: { userId: 'user123', action: 'create' }
      },
      service: null,
      contracts: mockContracts
    });
    
    expect(result?.context?.userId).toBe('user123');
    expect(result?.services).toHaveLength(1);
    expect(result?.services?.[0].type).toBe('com.validation.check');
  });
  
  it('should complete workflow on successful validation', async () => {
    const handler = userProcessingHandler['1.0.0'];
    
    const result = await handler({
      span: mockSpan,
      metadata: mockMetadata,
      collectedEvents: {},
      context: { userId: 'user123', step: 'validating' },
      input: null,
      service: {
        type: 'evt.validation.success',
        data: { valid: true }
      },
      contracts: mockContracts
    });
    
    expect(result?.output?.success).toBe(true);
  });
});
</code><button type="button">Copy</button></pre>

<h3 id="integration-testing" class="tsd-anchor-link">Integration Testing<a href="#integration-testing" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><pre><code class="typescript">import { SimpleMachineMemory } from 'arvo-xstate';

describe('UserProcessing Integration', () => {
  it('should complete full workflow', async () => {
    const memory = new SimpleMachineMemory();
    const orchestrator = createArvoResumable({
      memory,
      // ... config
    });
    
    // Send initialization event
    const initResult = await orchestrator.execute(initEvent);
    expect(initResult.events).toHaveLength(1);
    expect(initResult.events[0].type).toBe('com.validation.check');
    
    // Send validation response
    const validationResponse = createValidationSuccessEvent(/*...*/);
    const finalResult = await orchestrator.execute(validationResponse);
    expect(finalResult.events).toHaveLength(1);
    expect(finalResult.events[0].type).toBe('evt.com.user.processing.complete');
  });
});
</code><button type="button">Copy</button></pre>

<h2 id="best-practices" class="tsd-anchor-link">Best Practices<a href="#best-practices" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><h3 id="handler-design" class="tsd-anchor-link">Handler Design<a href="#handler-design" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><ol>
<li><strong>Keep handlers pure</strong>: Avoid side effects beyond returned actions</li>
<li><strong>Use type safety</strong>: Leverage TypeScript for compile-time validation</li>
<li><strong>Handle all cases</strong>: Consider initialization, service responses, and error scenarios</li>
<li><strong>Implement idempotency</strong>: Handlers may be called multiple times with the same input</li>
</ol>
<h3 id="state-management" class="tsd-anchor-link">State Management<a href="#state-management" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><ol>
<li><strong>Minimize state size</strong>: Store only essential workflow data</li>
<li><strong>Use immutable updates</strong>: Return new state objects rather than modifying existing ones</li>
<li><strong>Validate state transitions</strong>: Ensure state changes are logical and consistent</li>
<li><strong>Consider serialization</strong>: State must be JSON serializable for persistence</li>
</ol>
<h3 id="error-handling" class="tsd-anchor-link">Error Handling<a href="#error-handling" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><ol>
<li><strong>Distinguish error types</strong>: Use appropriate error handling for different failure modes</li>
<li><strong>Implement graceful degradation</strong>: Handle service failures without breaking workflows</li>
<li><strong>Provide meaningful errors</strong>: Include context and recovery suggestions in error messages</li>
<li><strong>Monitor error patterns</strong>: Track and alert on recurring error conditions</li>
</ol>
<h3 id="performance-optimization" class="tsd-anchor-link">Performance Optimization<a href="#performance-optimization" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><ol>
<li><strong>Optimize handler execution</strong>: Keep business logic efficient and avoid blocking operations</li>
<li><strong>Minimize state size</strong>: Large state objects impact serialization and network performance</li>
<li><strong>Batch service calls</strong>: Group related service invocations when possible</li>
<li><strong>Use appropriate locking</strong>: Enable locking only when necessary for correctness</li>
</ol>
<h2 id="deployment-considerations" class="tsd-anchor-link">Deployment Considerations<a href="#deployment-considerations" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><h3 id="memory-requirements" class="tsd-anchor-link">Memory Requirements<a href="#memory-requirements" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><ul>
<li>State size impacts memory usage and serialization performance</li>
<li>Consider archiving completed workflows to manage memory consumption</li>
<li>Monitor memory usage patterns under load</li>
</ul>
<h3 id="scaling-strategies" class="tsd-anchor-link">Scaling Strategies<a href="#scaling-strategies" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><ul>
<li>Horizontal scaling through multiple orchestrator instances</li>
<li>Partition workflows by subject or domain for better distribution</li>
<li>Use external state stores for high-volume scenarios</li>
</ul>
<h3 id="monitoring-and-alerts" class="tsd-anchor-link">Monitoring and Alerts<a href="#monitoring-and-alerts" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><ul>
<li>Track workflow completion rates and error patterns</li>
<li>Monitor lock contention and acquisition times</li>
<li>Alert on transaction violations and infrastructure failures</li>
<li>Implement health checks for orchestrator instances</li>
</ul>
<h2 id="migration-from-state-machines" class="tsd-anchor-link">Migration from State Machines<a href="#migration-from-state-machines" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>ArvoResumable provides a simpler alternative to state machine orchestration:</p>
<h3 id="key-differences" class="tsd-anchor-link">Key Differences<a href="#key-differences" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><table>
<thead>
<tr>
<th>Aspect</th>
<th>State Machines</th>
<th>ArvoResumable</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Programming Model</strong></td>
<td>Declarative state definitions</td>
<td>Imperative handler functions</td>
</tr>
<tr>
<td><strong>Learning Curve</strong></td>
<td>Requires XState knowledge</td>
<td>Uses familiar async/await patterns</td>
</tr>
<tr>
<td><strong>Debugging</strong></td>
<td>State visualization tools</td>
<td>Standard debugging techniques</td>
</tr>
<tr>
<td><strong>Complexity</strong></td>
<td>Good for complex state logic</td>
<td>Better for linear workflows</td>
</tr>
<tr>
<td><strong>Type Safety</strong></td>
<td>Event-driven type inference</td>
<td>Direct TypeScript types</td>
</tr>
</tbody>
</table>
<h3 id="when-to-choose-arvoresumable" class="tsd-anchor-link">When to Choose ArvoResumable<a href="#when-to-choose-arvoresumable" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><ul>
<li><strong>Linear workflows</strong> with simple request-response patterns</li>
<li><strong>Teams familiar</strong> with imperative programming</li>
<li><strong>Rapid prototyping</strong> requirements</li>
<li><strong>Simple state management</strong> needs</li>
<li><strong>Direct control</strong> over workflow logic preferred</li>
</ul>
<h3 id="when-to-choose-state-machines" class="tsd-anchor-link">When to Choose State Machines<a href="#when-to-choose-state-machines" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><ul>
<li><strong>Complex state logic</strong> with many conditional branches</li>
<li><strong>Parallel execution</strong> requirements</li>
<li><strong>Visual workflow</strong> modeling important</li>
<li><strong>Declarative approach</strong> preferred</li>
<li><strong>Complex timing</strong> and guard conditions</li>
</ul>
<h2 id="conclusion" class="tsd-anchor-link">Conclusion<a href="#conclusion" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>ArvoResumable provides a powerful yet approachable framework for distributed workflow orchestration. By emphasizing explicit control and familiar programming patterns, it enables teams to build reliable event-driven systems without the complexity of state machine abstractions.</p>
<p>The combination of contract-driven development, comprehensive error handling, multi-domain event routing, and built-in observability makes ArvoResumable an excellent choice for teams looking to implement robust workflow orchestration in their event-driven architectures.</p>
<p>Whether you're building simple request-response workflows or complex multi-service orchestrations, ArvoResumable provides the tools and patterns needed to create maintainable, scalable, and reliable distributed systems.</p>
</div></div><div class="col-sidebar"><div class="page-menu"><div class="tsd-navigation settings"><details class="tsd-accordion"><summary class="tsd-accordion-summary"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" aria-hidden="true"><use href="../assets/icons.svg#icon-chevronDown"></use></svg><h3>theme_settings</h3></summary><div class="tsd-accordion-details"><div class="tsd-filter-visibility"><span class="settings-label">theme_member_visibility</span><ul id="tsd-filter-options"><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-protected" name="protected"/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>flag_protected</span></label></li><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-inherited" name="inherited" checked/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>flag_inherited</span></label></li><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-external" name="external"/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>flag_external</span></label></li></ul></div><div class="tsd-theme-toggle"><label class="settings-label" for="tsd-theme">theme_theme</label><select id="tsd-theme"><option value="os">theme_os</option><option value="light">theme_light</option><option value="dark">theme_dark</option></select></div></div></details></div><details open class="tsd-accordion tsd-page-navigation"><summary class="tsd-accordion-summary"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" aria-hidden="true"><use href="../assets/icons.svg#icon-chevronDown"></use></svg><h3>theme_on_this_page</h3></summary><div class="tsd-accordion-details"><a href="#arvoresumable"><span>Arvo<wbr/>Resumable</span></a><ul><li><a href="#overview"><span>Overview</span></a></li><li><ul><li><a href="#key-capabilities"><span>Key <wbr/>Capabilities</span></a></li></ul></li><li><a href="#getting-started"><span>Getting <wbr/>Started</span></a></li><li><ul><li><a href="#basic-setup"><span>Basic <wbr/>Setup</span></a></li></ul></li><li><a href="#multi-domain-event-broadcasting"><span>Multi-<wbr/>Domain <wbr/>Event <wbr/>Broadcasting</span></a></li><li><ul><li><a href="#understanding-domains"><span>Understanding <wbr/>Domains</span></a></li><li><a href="#domain-assignment-rules"><span>Domain <wbr/>Assignment <wbr/>Rules</span></a></li><li><a href="#domain-broadcasting-patterns"><span>Domain <wbr/>Broadcasting <wbr/>Patterns</span></a></li><li><a href="#error-broadcasting"><span>Error <wbr/>Broadcasting</span></a></li></ul></li><li><a href="#handler-function-architecture"><span>Handler <wbr/>Function <wbr/>Architecture</span></a></li><li><ul><li><a href="#handler-signature"><span>Handler <wbr/>Signature</span></a></li><li><a href="#handler-parameters"><span>Handler <wbr/>Parameters</span></a></li><li><a href="#return-values"><span>Return <wbr/>Values</span></a></li></ul></li><li><a href="#event-collection-and-processing"><span>Event <wbr/>Collection and <wbr/>Processing</span></a></li><li><a href="#workflow-lifecycle-management"><span>Workflow <wbr/>Lifecycle <wbr/>Management</span></a></li><li><ul><li><a href="#status-management"><span>Status <wbr/>Management</span></a></li><li><a href="#event-tracking"><span>Event <wbr/>Tracking</span></a></li></ul></li><li><a href="#parent-child-orchestration-relationships"><span>Parent-<wbr/>Child <wbr/>Orchestration <wbr/>Relationships</span></a></li><li><ul><li><a href="#creating-child-orchestrations"><span>Creating <wbr/>Child <wbr/>Orchestrations</span></a></li><li><a href="#handling-child-completion"><span>Handling <wbr/>Child <wbr/>Completion</span></a></li><li><a href="#domain-context-in-parent-child-relationships"><span>Domain <wbr/>Context in <wbr/>Parent-<wbr/>Child <wbr/>Relationships</span></a></li></ul></li><li><a href="#advanced-patterns"><span>Advanced <wbr/>Patterns</span></a></li><li><ul><li><a href="#conditional-workflow-branching"><span>Conditional <wbr/>Workflow <wbr/>Branching</span></a></li><li><a href="#event-aggregation"><span>Event <wbr/>Aggregation</span></a></li><li><a href="#human-in-the-loop-workflows"><span>Human-<wbr/>in-<wbr/>the-<wbr/>Loop <wbr/>Workflows</span></a></li></ul></li><li><a href="#error-handling-philosophy"><span>Error <wbr/>Handling <wbr/>Philosophy</span></a></li><li><ul><li><a href="#transaction-errors-vs-system-error-events"><span>Transaction <wbr/>Errors vs <wbr/>System <wbr/>Error <wbr/>Events</span></a></li><li><a href="#error-handling-in-practice"><span>Error <wbr/>Handling in <wbr/>Practice</span></a></li></ul></li><li><a href="#resource-locking-and-concurrency"><span>Resource <wbr/>Locking and <wbr/>Concurrency</span></a></li><li><ul><li><a href="#automatic-locking-strategy"><span>Automatic <wbr/>Locking <wbr/>Strategy</span></a></li><li><a href="#lock-acquisition-behavior"><span>Lock <wbr/>Acquisition <wbr/>Behavior</span></a></li></ul></li><li><a href="#observability-and-monitoring"><span>Observability and <wbr/>Monitoring</span></a></li><li><ul><li><a href="#opentelemetry-integration"><span>Open<wbr/>Telemetry <wbr/>Integration</span></a></li><li><a href="#performance-monitoring"><span>Performance <wbr/>Monitoring</span></a></li></ul></li><li><a href="#testing-arvoresumable-workflows"><span>Testing <wbr/>Arvo<wbr/>Resumable <wbr/>Workflows</span></a></li><li><ul><li><a href="#unit-testing-handlers"><span>Unit <wbr/>Testing <wbr/>Handlers</span></a></li><li><a href="#integration-testing"><span>Integration <wbr/>Testing</span></a></li></ul></li><li><a href="#best-practices"><span>Best <wbr/>Practices</span></a></li><li><ul><li><a href="#handler-design"><span>Handler <wbr/>Design</span></a></li><li><a href="#state-management"><span>State <wbr/>Management</span></a></li><li><a href="#error-handling"><span>Error <wbr/>Handling</span></a></li><li><a href="#performance-optimization"><span>Performance <wbr/>Optimization</span></a></li></ul></li><li><a href="#deployment-considerations"><span>Deployment <wbr/>Considerations</span></a></li><li><ul><li><a href="#memory-requirements"><span>Memory <wbr/>Requirements</span></a></li><li><a href="#scaling-strategies"><span>Scaling <wbr/>Strategies</span></a></li><li><a href="#monitoring-and-alerts"><span>Monitoring and <wbr/>Alerts</span></a></li></ul></li><li><a href="#migration-from-state-machines"><span>Migration from <wbr/>State <wbr/>Machines</span></a></li><li><ul><li><a href="#key-differences"><span>Key <wbr/>Differences</span></a></li><li><a href="#when-to-choose-arvoresumable"><span>When to <wbr/>Choose <wbr/>Arvo<wbr/>Resumable</span></a></li><li><a href="#when-to-choose-state-machines"><span>When to <wbr/>Choose <wbr/>State <wbr/>Machines</span></a></li></ul></li><li><a href="#conclusion"><span>Conclusion</span></a></li></ul></div></details></div><div class="site-menu"><nav class="tsd-navigation"><a href="../modules.html">arvo-event-handler</a><ul class="tsd-small-nested-navigation" id="tsd-nav-container"><li>theme_loading</li></ul></nav></div></div></div><footer><p class="tsd-generator">Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a> with <a href="https://github.com/JulianWowra/typedoc-github-theme" target="_blank">typedoc-github-theme</a></p></footer><div class="overlay"></div></body></html>
