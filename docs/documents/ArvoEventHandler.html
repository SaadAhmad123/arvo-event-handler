<!DOCTYPE html><html class="default" lang="en" data-base="../"><head><meta charset="utf-8"/><meta http-equiv="x-ua-compatible" content="IE=edge"/><title>ArvoEventHandler | arvo-event-handler</title><meta name="description" content="Documentation for arvo-event-handler"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="../assets/style.css"/><link rel="stylesheet" href="../assets/highlight.css"/><script defer src="../assets/main.js"></script><script async src="../assets/icons.js" id="tsd-icons-script"></script><script async src="../assets/search.js" id="tsd-search-script"></script><script async src="../assets/navigation.js" id="tsd-nav-script"></script><script async src="../assets/hierarchy.js" id="tsd-hierarchy-script"></script><link rel="stylesheet" href="../assets/typedoc-github-style.css"/></head><body><script>document.documentElement.dataset.theme = localStorage.getItem("tsd-theme") || "os";document.body.style.display="none";setTimeout(() => window.app?app.showPage():document.body.style.removeProperty("display"),500)</script><header class="tsd-page-toolbar"><div class="tsd-toolbar-contents container"><a href="../index.html" class="title">arvo-event-handler</a><div id="tsd-toolbar-links"></div><button id="tsd-search-trigger" class="tsd-widget" aria-label="theme_search"><svg width="16" height="16" viewBox="0 0 16 16" fill="none" aria-hidden="true"><use href="../assets/icons.svg#icon-search"></use></svg></button><dialog id="tsd-search" aria-label="theme_search"><input role="combobox" id="tsd-search-input" aria-controls="tsd-search-results" aria-autocomplete="list" aria-expanded="true" autocapitalize="off" autocomplete="off" placeholder="theme_search_placeholder" maxLength="100"/><ul role="listbox" id="tsd-search-results"></ul><div id="tsd-search-status" aria-live="polite" aria-atomic="true"><div>theme_preparing_search_index</div></div></dialog><a href="#" class="tsd-widget menu" id="tsd-toolbar-menu-trigger" data-toggle="menu" aria-label="theme_menu"><svg width="16" height="16" viewBox="0 0 16 16" fill="none" aria-hidden="true"><use href="../assets/icons.svg#icon-menu"></use></svg></a></div></header><div class="container container-main"><div class="col-content"><div class="tsd-page-title"><ul class="tsd-breadcrumb" aria-label="Breadcrumb"><li><a href="" aria-current="page">ArvoEventHandler</a></li></ul></div><div class="tsd-panel tsd-typography"><h1 id="arvoeventhandler-implementation-of-a-reliable-event-driven-system" class="tsd-anchor-link">ArvoEventHandler - Implementation of a Reliable Event-Driven System<a href="#arvoeventhandler-implementation-of-a-reliable-event-driven-system" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h1><p>Event-driven architectures present distinct challenges in reliability and maintainability. Services must communicate dependably, manage errors effectively, and evolve without disrupting existing clients. The¬†<code>ArvoEventHandler</code>¬†addresses these challenges by transforming¬†<code>ArvoContract</code>¬†contracts into actively enforced rules for service communication. While¬†<code>ArvoContract</code>¬†defines a service's behaviour from the broader system's perspective,¬†<code>ArvoEventHandler</code>¬†binds with a contract to bring the service's functionality to life.</p>
<h1 id="getting-started-with" class="tsd-anchor-link">Getting Started with <code>ArvoEventHandler</code><a href="#getting-started-with" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h1><p>This section provides a hands-on introduction to building your first event handler with ArvoEventHandler. You'll learn how to transform an ArvoContract into a working service that processes events reliably.</p>
<h2 id="your-first-event-handler" class="tsd-anchor-link">Your First Event Handler<a href="#your-first-event-handler" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>Let's build on the user registration contract from the ArvoContract guide and create a working event handler.</p>
<h3 id="step-1-set-up-your-contract-and-dependencies" class="tsd-anchor-link">Step 1: Set Up Your Contract and Dependencies<a href="#step-1-set-up-your-contract-and-dependencies" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>First, let's establish our contract and create some mock dependencies to simulate real-world services:</p>
<pre><code class="typescript">// contracts/user-registration.ts
import { createArvoContract } from 'arvo-core';
import { z } from 'zod';

export const userRegistrationContract = createArvoContract({
    uri: '#/services/user/registration',
    type: 'com.user.register',
    versions: {
        '1.0.0': {
            accepts: z.object({
                email: z.string().email('Must be a valid email'),
                username: z.string().min(3, 'Username must be at least 3 characters'),
                password: z.string().min(8, 'Password must be at least 8 characters'),
            }),
            emits: {
                'evt.user.registered': z.object({
                    user_id: z.string(),
                    email: z.string(),
                    username: z.string(),
                    created_at: z.string().datetime(),
                }),
                'evt.user.registration.failed': z.object({
                    reason: z.string(),
                    error_code: z.enum(['EMAIL_EXISTS', 'USERNAME_TAKEN', 'INVALID_INPUT']),
                })
            }
        }
    }
});
</code><button type="button">Copy</button></pre>

<p>Let's create a mock data for demostation purposes in <code>services/database.ts</code></p>
<pre><code class="typescript">export class UserDatabase {
    private emails = new Set<string>();
    private usernames = new Set<string>();

    async emailExists(email: string): Promise<boolean> {
        return this.emails.has(email);
    }

    async usernameExists(username: string): Promise<boolean> {
        return this.usernames.has(username);
    }

    async createUser(email: string, username: string, password: string): Promise<string> {
        // Simulate async database operation
        await new Promise(resolve => setTimeout(resolve, 10));
        
        this.emails.add(email);
        this.usernames.add(username);
        
        return `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
}
</code><button type="button">Copy</button></pre>

<h3 id="step-2-create-your-event-handler" class="tsd-anchor-link">Step 2: Create Your Event Handler<a href="#step-2-create-your-event-handler" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>Now let's create the actual event handler using the factory pattern in <code>handlers/user-registration-handler.ts</code>:</p>
<pre><code class="typescript">import { createArvoEventHandler, type EventHandlerFactory } from 'arvo-event-handler';
import { logToSpan } from 'arvo-core';
import { userRegistrationContract } from '../contracts/user-registration';
import type { UserDatabase } from '../services/database';

type HandlerDependencies = {
    database: UserDatabase;
}

// Create the handler factory - this is the recommended pattern
export const userRegistrationHandlerFactory: EventHandlerFactory<HandlerDependencies> = ({
    database
}) => createArvoEventHandler({
  contract: userRegistrationContract,
  executionunits: 0.001, // Cost per execution (business-defined)
  handler: {
    '1.0.0': async ({ event, source, span }) => {
      logToSpan({
        level: 'INFO',
        message: `Processing user registration for ${event.data.email}`
      }, span);

      // Check if email already exists
      if (await database.emailExists(event.data.email)) {
        logToSpan({
          level: 'WARN',
          message: `Registration failed: Email ${event.data.email} already exists`
        }, span);

        return {
          type: 'evt.user.registration.failed',
          data: {
            reason: 'Email address already exists in the system',
            error_code: 'EMAIL_EXISTS'
          }
        };
      }

      // Check if username already exists
      if (await database.usernameExists(event.data.username)) {
        logToSpan({
          level: 'WARN',
          message: `Registration failed: Username ${event.data.username} already taken`
        }, span);

        return {
          type: 'evt.user.registration.failed',
          data: {
            reason: 'Username already taken',
            error_code: 'USERNAME_TAKEN'
          }
        };
      }

      // Create the user
      const userId = await database.createUser(
        event.data.email,
        event.data.username,
        event.data.password
      );

      logToSpan({
        level: 'INFO',
        message: `User ${userId} created successfully`
      }, span);

      // Return success event
      return {
        type: 'evt.user.registered',
        data: {
          user_id: userId,
          email: event.data.email,
          username: event.data.username,
          created_at: new Date().toISOString()
        }
      };
    }
  }
});
</code><button type="button">Copy</button></pre>

<h3 id="step-3-put-it-all-together" class="tsd-anchor-link">Step 3: Put It All Together<a href="#step-3-put-it-all-together" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>Let's create a complete example that shows how to use your event handler in <code>examples/complete-user-service.ts</code>:</p>
<pre><code class="typescript">import { createArvoEventFactory } from 'arvo-core';
import { userRegistrationContract } from '../contracts/user-registration';
import { userRegistrationHandlerFactory } from '../handlers/user-registration-handler';
import { UserDatabase } from '../services/database';

async function runUserRegistrationDemo() {
    // Set up dependencies
    const database = new UserDatabase();
    
    // Create the handler instance with dependencies
    const handler = userRegistrationHandlerFactory({ database });
    
    // Create an event factory for testing
    const eventFactory = createArvoEventFactory(userRegistrationContract.version('1.0.0'));

    console.log('=== User Registration Service Demo ===\n');

    // Test 1: Successful registration
    console.log('üìù Test 1: Successful user registration');
    const successEvent = eventFactory.accepts({
        source: 'com.web.frontend',
        data: {
            email: 'john.doe@example.com',
            username: 'johndoe',
            password: 'securepassword123'
        }
    });

    const successResult = await handler.execute(successEvent);
    console.log(`‚úÖ Result: ${successResult.events[0].type}`);
    console.log(`üìã Data:`, successResult.events[0].data);
    console.log('');

    // Test 2: Duplicate email
    console.log('üìù Test 2: Duplicate email registration');
    const duplicateEmailEvent = eventFactory.accepts({
        source: 'com.web.frontend',
        data: {
            email: 'john.doe@example.com', // Same email as above
            username: 'anotherjohn',
            password: 'anotherpassword123'
        }
    });

    const duplicateResult = await handler.execute(duplicateEmailEvent);
    console.log(`‚ùå Result: ${duplicateResult.events[0].type}`);
    console.log(`üìã Data:`, duplicateResult.events[0].data);
    console.log('');

    // Test 3: Duplicate username
    console.log('üìù Test 3: Duplicate username registration');
    const duplicateUsernameEvent = eventFactory.accepts({
        source: 'com.web.frontend',
        data: {
            email: 'jane.doe@example.com',
            username: 'johndoe', // Same username as first test
            password: 'janepassword123'
        }
    });

    const duplicateUsernameResult = await handler.execute(duplicateUsernameEvent);
    console.log(`‚ùå Result: ${duplicateUsernameResult.events[0].type}`);
    console.log(`üìã Data:`, duplicateUsernameResult.events[0].data);
    console.log('');

    // Test 4: Runtime error handling
    console.log('üìù Test 4: Runtime error handling');
    try {
        // Create an event with invalid data to trigger validation
        const invalidEvent = eventFactory.accepts({
            source: 'com.web.frontend',
            data: {
                email: 'not-an-email', // Invalid email
                username: 'ab', // Too short
                password: '123' // Too short
            }
        });
        
        await handler.execute(invalidEvent);
    } catch (error) {
        console.log(`üí• Caught validation error: ${error.message}`);
    }
}

// Run the demo
runUserRegistrationDemo().catch(console.error);
</code><button type="button">Copy</button></pre>

<h3 id="step-4-run-your-service" class="tsd-anchor-link">Step 4: Run Your Service<a href="#step-4-run-your-service" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><pre><code class="bash">npx tsx examples/complete-user-service.ts
</code><button type="button">Copy</button></pre>

<p>You should see output showing successful registrations, business logic errors (like duplicate emails), and validation errors being handled appropriately.</p>
<h2 id="advanced-patterns" class="tsd-anchor-link">Advanced Patterns<a href="#advanced-patterns" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><h3 id="handling-multiple-versions" class="tsd-anchor-link">Handling Multiple Versions<a href="#handling-multiple-versions" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>As your service evolves, you'll need to support multiple contract versions:</p>
<pre><code class="typescript">const handlerFactory: EventHandlerFactory<HandlerDependencies> = ({ database }) => 
    createArvoEventHandler({
        contract: userRegistrationContract,
        executionunits: 0.001,
        handler: {
            '1.0.0': async ({ event, span }) => {
                // Original implementation
                logToSpan({ level: 'INFO', message: 'Processing v1.0.0 registration' }, span);
                // ... implementation
            },
            '2.0.0': async ({ event, span }) => {
                // Enhanced implementation with new features
                logToSpan({ level: 'INFO', message: 'Processing v2.0.0 registration with enhanced validation' }, span);
                // ... enhanced implementation
            }
        }
    });
</code><button type="button">Copy</button></pre>

<h3 id="error-handling-strategy" class="tsd-anchor-link">Error Handling Strategy<a href="#error-handling-strategy" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>ArvoEventHandler distinguishes between different types of issues:</p>
<pre><code class="typescript">// Business logic errors - return as events
return {
    type: 'evt.user.registration.failed',
    data: { reason: 'Email exists', error_code: 'EMAIL_EXISTS' }
};

// Runtime errors - throw and let the handler convert to system errors
throw new Error('Database connection failed');

// Contract violations - these bubble up as ConfigViolation or ContractViolation
// These indicate serious system issues that need immediate attention
</code><button type="button">Copy</button></pre>

<h3 id="testing-your-handler" class="tsd-anchor-link">Testing Your Handler<a href="#testing-your-handler" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>Testing handlers is straightforward thanks to the factory pattern:</p>
<pre><code class="typescript">// test/user-registration-handler.test.ts
import { createArvoEventFactory } from 'arvo-core';
import { userRegistrationHandlerFactory } from '../handlers/user-registration-handler';
import { UserDatabase } from '../services/database';

describe('User Registration Handler', () => {
    let database: UserDatabase;
    let handler: ReturnType<typeof userRegistrationHandlerFactory>;
    let eventFactory: ReturnType<typeof createArvoEventFactory>;

    beforeEach(() => {
        database = new UserDatabase();
        handler = userRegistrationHandlerFactory({ database });
        eventFactory = createArvoEventFactory(userRegistrationContract.version('1.0.0'));
    });

    it('should successfully register a new user', async () => {
        const event = eventFactory.accepts({
            source: 'test',
            data: {
                email: 'test@example.com',
                username: 'testuser',
                password: 'password123'
            }
        });

        const result = await handler.execute(event);

        expect(result.events).toHaveLength(1);
        expect(result.events[0].type).toBe('evt.user.registered');
        expect(result.events[0].data.user_id).toBeDefined();
    });

    it('should reject duplicate emails', async () => {
        // Create first user
        await database.createUser('test@example.com', 'user1', 'pass');

        const event = eventFactory.accepts({
            source: 'test',
            data: {
                email: 'test@example.com',
                username: 'user2',
                password: 'password123'
            }
        });

        const result = await handler.execute(event);

        expect(result.events[0].type).toBe('evt.user.registration.failed');
        expect(result.events[0].data.error_code).toBe('EMAIL_EXISTS');
    });
});
</code><button type="button">Copy</button></pre>

<h2 id="whats-next" class="tsd-anchor-link">What's Next?<a href="#whats-next" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>Now that you understand the basics of ArvoEventHandler, you can explore:</p>
<ol>
<li><strong><a href="#managing-service-evolution-through-contracts">Contract Evolution</a></strong> - Learn how to evolve your handlers while maintaining backward compatibility</li>
<li><strong><a href="#multi-domain-event-broadcasting">Multi-Domain Broadcasting</a></strong> - Route events to different processing contexts</li>
<li><strong><a href="#error-handling">Error Handling Strategies</a></strong> - Master the different types of errors and how to handle them</li>
<li><strong><a href="#testing-event-handlers-in-arvo">Testing Patterns</a></strong> - Build comprehensive test suites for your handlers</li>
<li><strong><a href="./ArvoOrchestrator.md">Orchestration</a></strong> - Coordinate complex workflows across multiple services</li>
</ol>
<p>The patterns you've learned here form the foundation for building reliable, evolvable event-driven systems with Arvo.</p>
<h2 id="principles-of-reliable-event-driven-systems" class="tsd-anchor-link">Principles of Reliable Event-Driven Systems<a href="#principles-of-reliable-event-driven-systems" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>Arvo is engineered as an evolutionary event-driven architecture that strives to create systems that are reliable, adaptable, and transparent. In event-driven systems, the majority of complexity stems from inter-service communication. Arvo manages these complexities by enforcing several fundamental principles:</p>
<ol>
<li>All interservice communication is async and event driven</li>
<li>All events in the system are¬†<code>ArvoEvent</code>, which extends¬†<code>CloudEvent</code>¬†with additional routing and opentelemetry extensions</li>
<li>All interservice communications are bound and validated by a contract system, with services coupling to contracts rather than directly to other services and channels</li>
</ol>
<p>Service contracts are not novel; various specifications exist for defining them, such as OpenAPI, AsyncAPI, and Protocol Buffers. However, in practice, these specifications often devolve into producer-driven documentation or become outdated unless development teams maintain extremely rigorous standards. This degradation occurs because software systems are living entities that evolve over time, managed by diverse teams with varying priorities and perspectives.</p>
<p>In an ideal scenario, these contracts serve as crucial tools for creating evolvable and reliable systems. When the entire system recognizes service contracts and consistently upholds them, inter-service communication becomes dependable. Service developers gain the freedom to modify their implementations as needed, provided they maintain their contractual obligations. Furthermore, when properly implemented and thoughtfully designed, these contracts create robust pathways for system evolution while preserving backward compatibility. However, practical limitations in both specifications and ecosystems often prevent achieving these ideal outcomes.</p>
<h2 id="contract-first-development-in-typescript" class="tsd-anchor-link">Contract-First Development in TypeScript<a href="#contract-first-development-in-typescript" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>Arvo draws inspiration from established service contract practices and foundational software engineering theories, including Meyer's Design by Contract and Fowler's Tolerant Reader pattern, to create a more robust and naturally enforceable contract system. At its core, Arvo champions a contract-first development approach, implementing contracts as TypeScript objects that provide comprehensive type safety. The framework's <code>ArvoEventHandler</code> must be paired with an <code>ArvoContract</code> to create service implementations, ensuring consistent contract enforcement throughout the development lifecycle.</p>
<blockquote>
<p>While this approach makes Arvo specifically TypeScript-oriented, the underlying principles can be implemented in any programming language. Arvo considers this TypeScript specialisation an acceptable trade-off for building evolutionary architectures, particularly given TypeScript's versatility in web development at all levels. The strong typing system and modern development features of TypeScript enable Arvo to provide a more cohesive and maintainable contract-based development experience.</p>
</blockquote>
<h2 id="implementing-your-first-arvo-service" class="tsd-anchor-link">Implementing Your First Arvo Service<a href="#implementing-your-first-arvo-service" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>Building services with ArvoEventHandler follows a thoughtful, contract-first approach that ensures type safety and maintainable code. The process begins with contract definition and moves through to implementation, with TypeScript's type system helping ensure correctness at every step.</p>
<p>Let's explore a practical example of creating a user service. We'll start by importing the necessary components and defining our contract. The contract will specify what our service accepts and what it can emit:</p>
<pre><code class="typescript">import { createArvoContract, type ArvoEvent } from 'arvo-core';
import { createArvoEventHandler } from 'arvo-event-handler';
import z from 'zod';

// Our contract defines the service interface
const userCreateContract = createArvoContract({
    uri: "#/sample/user/create",
    type: "com.create.user",
    versions: {
        "1.0.0": {
            accepts: z.object({
                name: z.string(),
                age: z.number(),
            }),
            emits: {
                "evt.create.user.success": z.object({
                    created: z.boolean()
                })
            }
        },
    }
});
</code><button type="button">Copy</button></pre>

<p>With our contract in place, we can define the core business logic of our service. By separating this logic from the event handling, we maintain cleaner code organization and make our service easier to test:</p>
<pre><code class="typescript">const createUser = (name: string, age: number): boolean => {
    // Implementation of user creation logic
    return true; // Simplified for example
};
</code><button type="button">Copy</button></pre>

<blockquote>
<p>While this example demonstrates a clean separation of concerns by extracting the business logic into a standalone function, real-world service development often follows a different path. In practice, it's often more effective to start by implementing the functionality directly within the handler function. This approach allows you to fully understand the service's requirements and usage patterns in context. As the service matures and patterns emerge through actual use, you can then thoughtfully extract and abstract common functionalities. This evolution-based approach helps prevent premature abstractions and ensures that when you do create separate functions, they genuinely serve the service's needs and reflect real usage patterns rather than speculative design.</p>
</blockquote>
<p>Now we can create our event handler, binding it to our contract and implementing the business logic for each version. The handler maps incoming events to their appropriate version-specific implementations:</p>
<pre><code class="typescript">const handlerFactory: EventHandlerFactory = () => createArvoEventHandler({
    contract: userCreateContract,
    executionunits: 1, // Business-defined execution cost
    handler: {
        // Version-specific implementation
        '1.0.0': async ({event}) => {
            const userCreated = createUser(
                event.data.name,
                event.data.age
            );
            return {
                type: 'evt.create.user.success',
                data: { created: userCreated },
            };
        },
    }
});

const handler = handlerFactory()
</code><button type="button">Copy</button></pre>

<p>Notice how the handler's version key ('1.0.0') corresponds to the contract version. When an event arrives with a matching <code>dataschema</code> version, the handler routes it to the appropriate implementation. This versioning system ensures that each implementation adheres strictly to its contract version, allowing the service to evolve while maintaining backward compatibility. Developers can modify the implementation details freely as long as they maintain the contract's requirements.</p>
<h3 id="the-factory-pattern-" class="tsd-anchor-link">The factory pattern - <code>EventHandlerFactory</code><a href="#the-factory-pattern-" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>The <code>EventHandlerFactory</code> is a core type in the <code>arvo-event-handler</code> package that provides the foundation for creating event handlers. Rather than directly using <code>createArvoEventHandler</code>, services should be built using this factory type. It enforces a consistent pattern for dependency injection by defining an explicit contract for what a handler requires to function. When a developer implements the <code>EventHandlerFactory</code> type, they're creating a blueprint that specifies both the handler's dependencies and its implementation. This type-driven approach ensures that all necessary dependencies are properly declared and managed through TypeScript's type system, making the relationships between handlers and their required resources clear and maintainable.</p>
<pre><code class="typescript">import { type EventHandlerFactory, createArvoEventHandler } from 'arvo-event-handler';

interface HandlerDependencies {
    database: DatabaseClient;
    config: {
        maxRetries: number;
        timeout: number;
    };
    logger: Logger;
}

const userCreateHandlerFactory: EventHandlerFactory<HandlerDependencies> = ({
    database,
    config,
    logger
}) => createArvoEventHandler({
    contract: userCreateContract,
    executionunits: 1,
    handler: {
        '1.0.0': async ({event, span}) => {
            // Dependencies are available in scope
            logger.info('Processing user creation');
            const user = await database.createUser(event.data);
            return {
                type: 'evt.create.user.success',
                data: { created: true }
            };
        }
    }
});
</code><button type="button">Copy</button></pre>

<p>While the factory pattern may initially appear to introduce additional boilerplate compared to direct handler creation, this structure serves a crucial architectural purpose. Even for handlers without dependencies, using¬†<code>EventHandlerFactory</code>establishes a consistent pattern across all services and enables future evolution. Services that start simple often grow to require dependencies as business needs evolve - using the factory pattern from the start makes this transition seamless without requiring structural changes to the codebase. The factory pattern also maintains uniformity in how services are constructed and tested across a system, making codebases more maintainable and easier to understand for development teams.</p>
<h3 id="anatomy-of-a-handler-function" class="tsd-anchor-link">Anatomy of a handler function<a href="#anatomy-of-a-handler-function" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>When implementing a <code>ArvoEventHandler</code>, each version of your service gets its own dedicated function for processing events. The handler function is always an asynchronous function that receives a rich context object containing three key pieces of information:</p>
<ul>
<li>The <code>event</code> is a pre-validated input that has been rigorously checked against the contract's schema before reaching the handler. This validation ensures that by the time the handler receives the event, its structure is guaranteed to be correct. TypeScript integration provides additional safety: your IDE will offer intelligent autocomplete for data fields, and the TypeScript compiler will immediately highlight any type mismatches or structural errors during development.</li>
<li>The <code>source</code> parameter represents the service's identity, typically matching the contract's type.</li>
<li>The <code>span</code> is an OpenTelemetry tracing object that enables sophisticated observability. It allows developers to add rich metadata and logging information throughout the service's execution trace, providing deep insights into the system's behaviour and performance.</li>
</ul>
<p>Here's how this data from the context come to life in a real event handler implementation:</p>
<pre><code class="typescript">import { logToSpan } from 'arvo-core'

const handler = createArvoEventHandler({
    contract: userCreateContract,
    executionunits: 1, // Business-defined execution cost
    handler: {
        // Version-specific implementation
        '1.0.0': async ({event, source, span}) => {
            // The types are:
            // - event: ArvoEvent
            // - source: string
            // - span: Span <from opentelemetry>
            //
            // Adding some more attributes for logging
            span.setAttribute('sample-service-name', source)

            // The function automatically figures of the appropriate span
            logToSpan({
                level: 'INFO',
                message: "Service started"
            })

            const userCreated = createUser(
                event.data.name,
                event.data.age
            );

            // The target span to log event to can explicitly be defined
            logToSpan({
                level: 'INFO',
                message: "Service started"
            }, span)
            
            span.setAttribute('sample-execution-cost', 10)

            return {
                type: 'evt.create.user.success',
                data: { created: userCreated },
            };
        },
    }
});
</code><button type="button">Copy</button></pre>

<p>This example demonstrates an Arvo event handler for user creation that leverages OpenTelemetry tracing. It adds custom attributes to the span (like service name and execution cost), logs informational messages about the service's execution, and performs the core user creation logic. The handler uses both implicit and explicit logging with¬†<code>logToSpan</code>, showcasing how developers can easily inject observability into their event processing without disrupting the main business logic.</p>
<h3 id="logging-mechanism" class="tsd-anchor-link">Logging Mechanism<a href="#logging-mechanism" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>Arvo introduces <code>logToSpan</code>, a utility designed to integrate logging directly into OpenTelemetry tracing spans. This function enables developers to add structured <strong>log events</strong> throughout event processing while maintaining clean, uncluttered business logic.</p>
<p>With <code>logToSpan</code>, logging becomes a seamless part of observability. Developers can:</p>
<ul>
<li>Log messages with various severity levels</li>
<li>Attach contextual information</li>
<li>Precisely correlate logs with specific traces and spans</li>
</ul>
<p>The utility abstracts away the complexities of span management. Whether you want to use the current active span or explicitly specify a target span, <code>logToSpan</code> handles the details of log attachment automatically. This approach provides a consistent, developer-friendly method for capturing runtime information across distributed event-driven systems.</p>
<p>By integrating logging directly into the tracing mechanism, Arvo ensures that every log event is not just a message, but a rich, traceable piece of system log. Developers can focus on their core logic, knowing that observability is built-in and effortless.</p>
<h2 id="managing-service-evolution-through-contracts" class="tsd-anchor-link">Managing Service Evolution Through Contracts<a href="#managing-service-evolution-through-contracts" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The <code>ArvoEventHandler</code> takes a unique approach to contract versioning, treating each version as a completely independent entity, both functionally and semantically. This design isn't just a technical choice - it reflects Arvo's fundamental philosophy about how services should evolve in distributed systems.</p>
<p>When an <code>ArvoEventHandler</code> binds to a contract, it enforces a strict requirement: every version defined in the <code>ArvoContract</code> must have a corresponding implementation in the handler. While this might initially seem to promote code duplication, it serves a deeper purpose. This approach ensures complete and reliable backward compatibility while giving developers the freedom to implement version-specific business logic and manage their deprecation strategies according to business needs.</p>
<p>Let's explore this through a practical example. Imagine a scenario where a new consumer needs to provide a date of birth instead of age when creating users. This requirement may leads us to create a new contract version:</p>
<pre><code class="typescript">import { createArvoContract, type ArvoEvent } from 'arvo-core';
import { createArvoEventHandler } from 'arvo-event-handler';
import z from 'zod';

const userCreateContract = createArvoContract({
    uri: "#/sample/user/create",
    type: "com.create.user",
    versions: {
        "1.0.0": {
            accepts: z.object({
                name: z.string(),
                age: z.number(),
            }),
            emits: {
                "evt.create.user.success": z.object({
                    created: z.boolean()
                })
            }
        },
        "2.0.0": {
            accepts: z.object({
                name: z.string(),
                dob: z.string(), // Changed from age to date of birth
            }),
            emits: {
                "evt.create.user.success": z.object({
                    created: z.boolean()
                })
            }
        }
    }
});
</code><button type="button">Copy</button></pre>

<blockquote>
<p><strong>Interesting Point</strong>: According to the ArvoContract documentation, introducing a new field format (changing from age to dob) could be handled through a union type in the same version since it increases permissiveness while preserving existing functionality. While this would result in less code, creating a new version offers cleaner separation of concerns and easier tracking of consumer requirements. Consider your specific needs - union types for simpler changes and gradual adoption, new versions for clearer boundaries and independent evolution paths. Both approaches are valid within Arvo's contract evolution principles; choose based on your maintenance strategy and consumer needs.</p>
</blockquote>
<p>Rather than duplicating all our business logic, we can maintain our core functionality while adding version-specific transformations. Notice how the <code>createUser</code> function remains unchanged while we add a new helper function to handle the date of birth conversion:</p>
<pre><code class="typescript">const createUser = (name: string, age: number): boolean => {
    // Core business logic remains stable
    return true;
};

const calculateAge = (dob: string): number => {
    const birthDate = new Date(dob);
    const today = new Date();
    return today.getFullYear() - birthDate.getFullYear();
};

const handlerFactory: EventHandlerFactory = () => createArvoEventHandler({
    contract: userCreateContract,
    executionunits: 1,
    handler: {
        '1.0.0': async ({event}) => {
            const userCreated = createUser(
                event.data.name,
                event.data.age
            );
            return {
                type: 'evt.create.user.success',
                data: { created: userCreated }
            };
        },
        '2.0.0': async ({event}) => {
            const age = calculateAge(event.data.dob);
            const userCreated = createUser(
                event.data.name,
                age
            );
            return {
                type: 'evt.create.user.success',
                data: { created: userCreated },
                executionunits: 2, // A override cost specific to this version 
            };
        }
    }
});

const handler = handlerFactory()
</code><button type="button">Copy</button></pre>

<p>This pattern demonstrates how Arvo promotes evolution while maintaining reliability. The isolation between handler functions for different versions is intentional - it allows each version to evolve independently while preserving the integrity of the service contract. This approach enables teams to add new consumers with different requirements while maintaining existing functionality, and it provides the flexibility to implement sunset strategies based on business needs rather than technical limitations.</p>
<p>The slight increase in code volume is a conscious trade-off, chosen to prioritise system reliability and evolution over code conciseness. This approach may proven particularly valuable in large-scale systems where the cost of breaking changes far outweighs the cost of maintaining version-specific handlers.</p>
<h2 id="event-processing-and-execution-flow" class="tsd-anchor-link">Event Processing and Execution Flow<a href="#event-processing-and-execution-flow" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>To demonstrate how this all works together, let's look at a simple execution flow that shows how events flow through the system - from creation through processing to response:</p>
<pre><code class="typescript">async function main() {
    const inputEvent: ArvoEvent = createArvoEventFactory(
        userCreateContract.version('1.0.0')
    ).accepts({
        subject: "some-subject",
        source: "com.test.test",
        data: {
            name: "John Doe",
            age: 65
        }
    })
    
    const result: ArvoEvent[] = await handler.execute(
         inputEvent        
    )
}
main().catch(console.error)
</code><button type="button">Copy</button></pre>

<h3 id="what-happens-here" class="tsd-anchor-link">What Happens Here?<a href="#what-happens-here" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>Let's break down this execution flow to understand how Arvo processes events through the system. The execution begins with event creation through the¬†<code>createArvoEventFactory</code>. This factory, initialized with version '1.0.0' of our contract, ensures all event creation strictly follows the version's schema specifications.</p>
<p>The¬†<code>accepts</code>¬†method then generates an event matching our contract's input requirements, carefully structuring the data with¬†<code>name</code>¬†and¬†<code>age</code>¬†fields to align with our contract's accept schema. This ensures type safety from the very beginning of our event's lifecycle.</p>
<p>The core processing occurs when we call¬†<code>handler.execute</code>. The handler first validates the incoming event against the contract specifications. Upon successful validation, it routes the event to the correct version-specific implementation by examining the event's¬†<code>dataschema</code>. This implementation then processes the event according to its business logic and produces response events. Before these response events leave the handler, they undergo validation against the contract's emit schema, ensuring they meet all specified requirements.</p>
<p>At the end of this flow, we receive our array of response events stored in¬†<code>result</code>. Each event in this array has been fully validated and is guaranteed to conform to our contract's specifications, maintaining the integrity of our service's communication interface.</p>
<h3 id="understanding-the-handler-interface" class="tsd-anchor-link">Understanding the Handler Interface<a href="#understanding-the-handler-interface" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>All event handlers in Arvo follow a consistent signature:¬†<code>ArvoEvent =&gt; Promise&lt;{ events:ArvoEvent[] }&gt;</code>. This unified interface offers several key advantages:</p>
<p>This simple yet powerful pattern means every handler takes an ArvoEvent as input and returns a Promise that resolves to an array of ArvoEvents. The promise wrapper enables asynchronous processing, while returning an array of events allows handlers to trigger multiple consequent actions when needed. This uniformity creates a predictable flow of events through the system, making it easier to reason about service behavior and compose complex workflows.</p>
<p>Whether you're building a simple service like our user creation example or orchestrating complex business processes, this consistent interface ensures that all services speak the same language and can be composed reliably. The handler's contract validation ensures that both incoming and outgoing events adhere to their specified schemas, maintaining type safety throughout the event chain.</p>
<h2 id="error-handling" class="tsd-anchor-link">Error Handling<a href="#error-handling" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>Error handling forms a critical foundation for building reliable event-driven systems. <code>ArvoEventHandler</code> implements a sophisticated error handling strategy that recognises different categories of issues and provides appropriate mechanisms for dealing with each.</p>
<p>At its core, Arvo distinguishes between two fundamental types of errors: system errors that occur during normal operation and can potentially be recovered from, and violations that indicate serious structural or configuration issues requiring immediate attention.</p>
<blockquote>
<p>When implementing handler functions, you should throw errors naturally and let them propagate. The¬†<code>ArvoEventHandler</code>will catch these errors and automatically transform them into appropriate system error events. The following sections explain what happens when you call¬†<code>handler.execute(event)</code>¬†and how different types of errors are processed.</p>
</blockquote>
<h3 id="system-error-events" class="tsd-anchor-link">System Error Events<a href="#system-error-events" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>System errors represent operational issues that occur during the normal execution of a service. These might include temporary network failures, resource constraints, or other transient conditions that could resolve with time or retry attempts. When an uncaught error occurs within a handler function, Arvo automatically converts it into a standardised system error event.</p>
<p>The system error events follow a consistent format defined by the <code>ArvoContract</code>, with the type <code>sys.&lt;contract-type&gt;.error</code>. This standardisation ensures that error handling remains consistent across the system and enables automated processing of error conditions. For example, in our user creation service, a system error event might look like this:</p>
<pre><code class="typescript">import { type ArvoErrorType, createArvoError, createArvoEvent } from 'arvo-core'

const sampleErrorEvent = createArvoEvent({
    ...rest,
    type: 'sys.com.user.create.error',
    data: createArvoError(
        new Error("Some random error")
    ), // satisfies ArvoErrorType
})

/**
 * The event will be...
 * ArvoEvent<ArvoErrorType, {}, `sys.com.user.create.error`>
 * = {
 *   type: "sys.com.user.create.error",
 *   data: {
 *      errorName: string,
 *      errorMessage: string,
 *      errorStack: string | null
 *   },
 *   ...rest
 * }
 */
</code><button type="button">Copy</button></pre>

<blockquote>
<p>While the example above shows the error event structure, developers should never create these error events directly. The <code>ArvoEventHandler</code> automatically generates and emits system errors when uncaught exceptions occur during execution. This ensures consistent error handling across the system.</p>
</blockquote>
<h3 id="violations" class="tsd-anchor-link">Violations<a href="#violations" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>While system errors represent operational issues, violations indicate fundamental problems with how the system is configured or being used. These are serious issues that could compromise system integrity if allowed to continue. Unlike system errors that are returned as events, violations are thrown as exceptions that must be handled explicitly.</p>
<p>Arvo defines three distinct types of violations, each serving a specific purpose in maintaining system integrity:</p>
<h4 id="configviolation" class="tsd-anchor-link">ConfigViolation<a href="#configviolation" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h4><p>The <code>ConfigViolation</code> indicates fundamental mismatches between events and their handlers. This might occur when events are routed to the wrong service (like sending a payment event to a user service) or when events specify nonexistent contract versions. These violations help catch system configuration errors before they can cause cascading failures.</p>
<h4 id="contractviolation" class="tsd-anchor-link">ContractViolation<a href="#contractviolation" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h4><p>The <code>ContractViolation</code> occurs when events fail to meet their contractual obligations. This happens when incoming or outgoing events fail schema validation, when event URIs don't match their handler contracts, or when data types don't align with schema requirements. These violations typically indicate implementation bugs or data corruption issues that require developer attention.</p>
<h4 id="executionviolation" class="tsd-anchor-link">ExecutionViolation<a href="#executionviolation" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h4><blockquote>
<p><strong>WARNING!</strong> Do not use it for normal business failures (leverage system errors mechanism), validation failures (leverage <code>ContractViolation</code>), routing issues (leverage <code>ConfigViolation</code>), or temporary failures that could succeed on retry.</p>
</blockquote>
<p><code>ExecutionViolation</code> is a developer-controlled mechanism for handling extraordinary cases. They serves as an infrastructure-level signal rather than an error condition. Its primary purpose is to act as a circuit breaker mechanism, indicating that message processing should cease and the event should be moved to a dead letter queue for investigation. This violation type is particularly useful in preventing harmful processing loops or handling unrecoverable semantic errors.</p>
<p>Handling violations in practice:</p>
<pre><code class="typescript">import type { ConfigViolation, ContractViolation, ExecutionViolation } from 'arvo-event-handler';

try {
    const result = await handler.execute(inputEvent);
    // Process successful result
} catch (error) {
    if ((e as ConfigViolation)?.name === 'ViolationError<Config>') {
        // Do something...
    }
    if ((e as ContractViolation)?.name === 'ViolationError<Contract>') {
        // Do something...
    }
    if ((e as ExecutionViolation)?.name === 'ViolationError<Execution>') {
        // Do something...
    }
}
</code><button type="button">Copy</button></pre>

<p>With this structured approach to error handling, Arvo attempts to enables developers to build robust, self-healing systems while ensuring that serious issues receive immediate attention.</p>
<h2 id="a-note-on-contract-validation-performance" class="tsd-anchor-link">A Note on Contract Validation Performance<a href="#a-note-on-contract-validation-performance" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>Contract validation is an integral part of the event handler execution process in Arvo, occurring for both incoming and outgoing events against the <code>ArvoContract</code>. While this might initially raise performance concerns, several architectural decisions help minimise any potential overhead.</p>
<p>At the core of Arvo's validation system lies the Zod package, a widely adopted TypeScript schema validation library. Zod not only handles validation but also manages default value population in a single pass, eliminating the need for separate processing steps. This integration provides a robust foundation for type safety while maintaining efficient execution.</p>
<p>The centralised validation approach through <code>ArvoContract</code> eliminates the need for individual validation logic in each handler implementation. This not only reduces code redundancy but also ensures consistency across services. In the context of distributed systems, the validation overhead is minimal compared to typical network latency and business logic execution times. Since validation is a necessary component of most applications, integrating it at the contract level provides comprehensive type safety without significant performance impact.</p>
<p>While Zod can face performance challenges when validating deeply nested structures, large datasets, or complex types like unions and arrays, these limitations are offset by its comprehensive feature set and mature API. To address potential IDE performance impacts in large systems with numerous contracts, Arvo recommends implementing contracts in separate packages distributed through monorepo structures or package registries. This approach leverages TypeScript's compilation process, generating declaration files that optimise IDE performance through transpiled type declarations.</p>
<p>It's worth noting that in typical event-driven architectures, these performance considerations rarely become bottlenecks, as network latency and database operations usually dominate the performance profile. For cases requiring exceptional performance, developers can implement custom handlers. Arvo's design philosophy prioritises reasonable performance for typical use cases rather than extreme computational efficiency.</p>
<blockquote>
<p>In Arvo's event-driven architecture, events typically serve as commands and responses between services. Since these events represent service interactions rather than data storage or transfer mechanisms, large event payloads may indicate a violation of single responsibility principles - where an event is trying to do too much or carry too much information. This could make the system harder to maintain and evolve over time. For scenarios involving large datasets, consider whether the data transfer could be better handled through other mechanisms while keeping the event focused on the service interaction itself.</p>
</blockquote>
<p>Here is the updated domain section of the README, rewritten to reflect the new domain semantics in ArvoEventHandler. It avoids dot points where not needed, emphasizes clarity, and aligns precisely with your finalized code and TSDoc structure.</p>
<h2 id="multi-domain-event-broadcasting" class="tsd-anchor-link">Multi-Domain Event Broadcasting<a href="#multi-domain-event-broadcasting" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>Arvo supports the controlled distribution of a single event across multiple processing contexts by using a domain broadcasting model. This model is implemented at the handler level, allowing any response event to be routed to one or more domain targets.</p>
<p>Domains in Arvo serve as routing contexts. They determine where and how an event is delivered once emitted. This value is becomes a part of the emitted <code>ArvoEvent</code> in <code>domain</code> field (which can either be a <code>string</code> or <code>null</code>). An event returned by a handler may specify an array of domain values. Each value in that array triggers the creation of a separate <code>ArvoEvent</code> with its domain field set accordingly. This approach makes it possible to target observability pipelines, compliance processors, partner integrations, human review queues, or any parallel system channel ‚Äî all from a single source event.</p>
<p>The domain array must be explicitly specified by the handler. If it is omitted entirely, Arvo will default to a single <code>domain: null</code>, which represents the default or ‚Äúno-domain‚Äù routing. This default is intentional and encouraged for standard flows that do not require specialized processing behavior.</p>
<p>Each domain value can either be a concrete string, such as <code>'audit.workflow'</code> or <code>'human.review'</code> (<strong>this is massively encouraged</strong>), or it can be a symbolic constant provided by <code>ArvoDomain</code>. These symbolic constants are interpreted at runtime and resolve to real domain strings based on the surrounding context.</p>
<p>The <code>ArvoDomain</code> object offers three such constants:
‚Ä¢ <code>FROM_SELF_CONTRACT</code>: This resolves to the domain declared on the emitting handler‚Äôs contract. It‚Äôs useful when the service has a defined domain identity and wants events it emits to align with that.
‚Ä¢ <code>FROM_EVENT_CONTRACT</code>: This resolves to the domain on the contract of the event being emitted. It ensures that responses inherit the routing context of the logical definition of the event.
‚Ä¢ <code>FROM_TRIGGERING_EVENT</code>: This resolves to the domain of the incoming event that triggered the handler. It allows handlers to propagate domain context from upstream services.</p>
<p>All domain values ‚Äî both symbolic and literal ‚Äî are resolved through a resolution function (<code>resolveArvoDomain</code>). After this resolution step, <strong>duplicate values are automatically deduplicated</strong>. This means if the resolved domain array includes multiple references that end up evaluating to the same domain string, only one event will be emitted for that domain.</p>
<p>If domain is explicitly set to [null], a single event will be emitted with <code>domain: null</code>. This is considered the standard behavior and should be the default for most use cases.</p>
<p>A symbolic value like <code>FROM_TRIGGERING_EVENT</code> will only resolve to a domain if the triggering event itself had a domain. If not, it will fall back to null, ensuring that domain-less events are still emitted rather than dropped or misrouted.</p>
<p>Here is the updated version of the #### System Error Event Broadcasting section, with a revised paragraph to reflect the new systemErrorDomain semantics:</p>
<h4 id="system-error-event-broadcasting" class="tsd-anchor-link">System Error Event Broadcasting<a href="#system-error-event-broadcasting" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h4><p>When an error occurs during event processing, Arvo emits a special <strong>system error event</strong> using the <code>sys.&lt;contract.type&gt;.error</code> naming convention. By default, these system error events are broadcast across <strong>three domains</strong> to ensure robust error visibility:</p>
<ul>
<li>the domain of the incoming event,</li>
<li>the domain defined on the handler‚Äôs contract (if present), and</li>
<li>a fallback null domain that represents the standard no-routing pipeline.</li>
</ul>
<p>This fallback triad ensures that downstream consumers monitoring any of those domains can observe the failure.</p>
<p>However, this default behavior can be <strong>overridden explicitly</strong> via the optional <code>systemErrorDomain</code> field on the handler definition. If this field is provided, it replaces the default error routing logic and allows developers to specify precise domain targets for system errors ‚Äî using literal strings, symbolic values from <code>ArvoDomain</code>, or null. This is particularly useful in workflows where error visibility must be tightly scoped or routed to specific operational teams. Regardless of how the domains are defined, Arvo applies the same resolution and deduplication rules to system errors as it does for normal event broadcasting, ensuring that each domain receives exactly one copy of the system error event.</p>
<h3 id="guiding-principal-for" class="tsd-anchor-link">Guiding principal for <code>domain</code><a href="#guiding-principal-for" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>As a guiding principle, domain usage should be deliberate and transparent. Setting <code>contract.domain</code> in the <code>ArvoContract</code> is strongly discouraged unless you know exactly how you intend the handler to operate in all cases. Implicit domain inheritance at the contract level can obscure event flow and introduce tightly coupled behavior that is difficult to reason about later.</p>
<p>Instead, each returned event should be responsible for defining its own domain behavior through the domain field. This leads to better modularity, more understandable flows, and easier debugging.</p>
<p>In short, use domains when your response event is meant for a specific kind of processing. If you want to signal that an event must be approved by a human, routed to a compliance archive, or streamed to an external analytics system ‚Äî assign it an appropriate domain. Otherwise, leave it as <code>null</code> and let it flow through the standard path.</p>
<h3 id="domain-broadcasting-pattern" class="tsd-anchor-link">Domain broadcasting pattern<a href="#domain-broadcasting-pattern" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>Let's look at extending the getting start example to use the domain broadcasting</p>
<h4 id="step-1-update-your-event-handler" class="tsd-anchor-link">Step 1: Update Your Event Handler<a href="#step-1-update-your-event-handler" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h4><p>We'll extend the handler to demonstrate domain broadcasting capabilities in <code>handlers/user-registration-handler.ts</code>:</p>
<pre><code class="typescript">import { createArvoEventHandler, type EventHandlerFactory, ArvoDomain } from 'arvo-event-handler';
import { logToSpan } from 'arvo-core';
import { userRegistrationContract } from '../contracts/user-registration';
import type { UserDatabase } from '../services/database';

type HandlerDependencies = {
    database: UserDatabase;
}

// Create the handler factory - this is the recommended pattern
export const userRegistrationHandlerFactory: EventHandlerFactory<HandlerDependencies> = ({
    database
}) => createArvoEventHandler({
  contract: userRegistrationContract,
  executionunits: 0.001, // Cost per execution (business-defined)
  handler: {
    '1.0.0': async ({ event, source, span, domain }) => {
      logToSpan({
        level: 'INFO',
        message: `Processing user registration for ${event.data.email}`
      }, span);

      // Log domain information for observability
      if (domain.event) {
        logToSpan({
          level: 'INFO',
          message: `Event received from domain: ${domain.event}`
        }, span);
      }

      // Check if email already exists
      if (await database.emailExists(event.data.email)) {
        logToSpan({
          level: 'WARN',
          message: `Registration failed: Email ${event.data.email} already exists`
        }, span);

        return {
          type: 'evt.user.registration.failed',
          data: {
            reason: 'Email address already exists in the system',
            error_code: 'EMAIL_EXISTS'
          },
          // Broadcast error to multiple domains for different processing contexts
          // along with the default 'null' no-domain event.
          domain: ['audit.failures', 'analytics.errors', null]
        };
      }

      // Check if username already exists
      if (await database.usernameExists(event.data.username)) {
        logToSpan({
          level: 'WARN',
          message: `Registration failed: Username ${event.data.username} already taken`
        }, span);

        return {
          type: 'evt.user.registration.failed',
          data: {
            reason: 'Username already taken',
            error_code: 'USERNAME_TAKEN'
          },
          // Send failure to audit
          domain: ['audit.failures']
        };
      }

      // Create the user
      const userId = await database.createUser(
        event.data.email,
        event.data.username,
        event.data.password
      );

      logToSpan({
        level: 'INFO',
        message: `User ${userId} created successfully`
      }, span);

      // Determine if this is a premium user based on email domain
      const isPremiumUser = event.data.email.endsWith('@premium.com');

      // Return success event with sophisticated domain broadcasting
      return {
        type: 'evt.user.registered',
        data: {
          user_id: userId,
          email: event.data.email,
          username: event.data.username,
          created_at: new Date().toISOString()
        },
        // Multi-domain broadcasting based on business logic
        domain: isPremiumUser ? 
          [
            'analytics.users',      // All user analytics
            'crm.premium',         // Premium user CRM
            'marketing.vip',       // VIP marketing campaigns
            null                   // Standard processing pipeline
          ] : 
          [
            'analytics.users',                                                  // All user analytics
            ArvoDomain.FROM_TRIGGERING_EVENT, ArvoDomain.FROM_SELF_CONTRACT,    // Inherit from event or handler domain
            null                                                                // Standard processing pipeline
          ]
      };
    }
  }
});
</code><button type="button">Copy</button></pre>

<h4 id="step-2-domain-broadcasting-examples" class="tsd-anchor-link">Step 2: Domain Broadcasting Examples<a href="#step-2-domain-broadcasting-examples" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h4><p>Let's also create a dedicated example that shows different domain broadcasting patterns in <code>examples/domain-broadcasting-demo.ts</code>:</p>
<pre><code class="typescript">
import { createArvoEventFactory } from 'arvo-core';
import { userRegistrationContract } from '../contracts/user-registration';
import { userRegistrationHandlerFactory } from '../handlers/user-registration-handler';
import { UserDatabase } from '../services/database';

async function runDomainBroadcastingDemo() {
    const database = new UserDatabase();
    const handler = userRegistrationHandlerFactory({ database });
    const eventFactory = createArvoEventFactory(userRegistrationContract.version('1.0.0'));

    console.log('=== Domain Broadcasting Demo ===\n');

    // Test 1: Premium user registration (multiple domains)
    console.log('üìù Test 1: Premium user registration');
    const premiumEvent = eventFactory.accepts({
        source: 'com.web.frontend',
        data: {
            email: 'john.doe@premium.com',
            username: 'johndoe',
            password: 'securepassword123'
        }
    });

    const premiumResult = await handler.execute(premiumEvent);
    console.log(`‚úÖ Generated ${premiumResult.events.length} events for premium user:`);
    premiumResult.events.forEach((event, index) => {
        console.log(`   Event ${index + 1}: type=${event.type}, domain=${event.domain || 'null'}`);
    });
    console.log('');

    // Test 2: Regular user registration (different domain pattern)
    console.log('üìù Test 2: Regular user registration');
    const regularEvent = eventFactory.accepts({
        source: 'com.web.frontend',
        data: {
            email: 'jane.smith@gmail.com',
            username: 'janesmith',
            password: 'anotherpassword123'
        }
    });

    const regularResult = await handler.execute(regularEvent);
    console.log(`‚úÖ Generated ${regularResult.events.length} events for regular user:`);
    regularResult.events.forEach((event, index) => {
        console.log(`   Event ${index + 1}: type=${event.type}, domain=${event.domain || 'null'}`);
    });
    console.log('');

    // Test 3: Email conflict (error broadcasting)
    console.log('üìù Test 3: Email conflict with domain broadcasting');
    const conflictEvent = eventFactory.accepts({
        source: 'com.web.frontend',
        data: {
            email: 'john.doe@premium.com', // Same as first test
            username: 'anotherjohn',
            password: 'conflictpassword123'
        }
    });

    const conflictResult = await handler.execute(conflictEvent);
    console.log(`‚ùå Generated ${conflictResult.events.length} error events:`);
    conflictResult.events.forEach((event, index) => {
        console.log(`   Event ${index + 1}: type=${event.type}, domain=${event.domain || 'null'}`);
        console.log(`   Error: ${event.data.error_code} - ${event.data.reason}`);
    });
    console.log('');

    // Test 4: Username conflict (single domain error)
    console.log('üìù Test 4: Username conflict with single domain');
    const usernameConflictEvent = eventFactory.accepts({
        source: 'com.web.frontend',
        data: {
            email: 'unique.email@example.com',
            username: 'johndoe', // Same as first test
            password: 'uniquepassword123'
        }
    });

    const usernameConflictResult = await handler.execute(usernameConflictEvent);
    console.log(`‚ùå Generated ${usernameConflictResult.events.length} error event:`);
    usernameConflictResult.events.forEach((event, index) => {
        console.log(`   Event ${index + 1}: type=${event.type}, domain=${event.domain || 'null'}`);
        console.log(`   Error: ${event.data.error_code} - ${event.data.reason}`);
    });
}

// Run the demo
runDomainBroadcastingDemo().catch(console.error);
</code><button type="button">Copy</button></pre>

<h4 id="understanding-domain-broadcasting-patterns" class="tsd-anchor-link">Understanding Domain Broadcasting Patterns<a href="#understanding-domain-broadcasting-patterns" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h4><p>When you run this example (<code>npx tsx examples/domain-broadcasting-demo.ts</code>), you'll see different domain broadcasting patterns in action:</p>
<p><strong>Premium User Success Event</strong> creates 4 events:</p>
<ul>
<li><code>domain: 'analytics.users'</code> - For user analytics processing</li>
<li><code>domain: 'crm.premium'</code> - For premium customer relationship management</li>
<li><code>domain: 'marketing.vip'</code> - For VIP marketing campaigns</li>
<li><code>domain: null</code> - For standard processing pipeline</li>
</ul>
<p><strong>Regular User Success Event</strong> creates 3 events:</p>
<ul>
<li><code>domain: 'analytics.users'</code> - For user analytics processing</li>
<li><code>domain: null</code> - From <code>ArvoDomain.FROM_TRIGGERING_EVENT, ArvoDomain.FROM_SELF_CONTRACT,</code> resolution (since no event or handler domain)</li>
<li><code>domain: null</code> - Explicit null domain (deduplication removes duplicate)</li>
</ul>
<p><strong>Email Conflict Error</strong> creates 3 events:</p>
<ul>
<li><code>domain: 'audit.failures'</code> - For failure auditing</li>
<li><code>domain: 'analytics.errors'</code> - For error analytics</li>
<li><code>domain: null</code> - For standard error processing</li>
</ul>
<p><strong>Username Conflict Error</strong> creates 1 event:</p>
<ul>
<li><code>domain: 'audit.failures'</code> - Single targeted domain for audit</li>
</ul>
<p>This demonstrates how domain broadcasting enables sophisticated event routing based on business logic, user types, and error conditions while maintaining clean separation of processing contexts.</p>
<h2 id="event-handler-scaling" class="tsd-anchor-link">Event Handler Scaling<a href="#event-handler-scaling" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The <code>ArvoEventHandler</code> execution model implements a functional architecture that inherently supports scalability in distributed systems. At its core, each handler is a pure function with the signature <code>ArvoEvent =&gt; Promise&lt;{ events:ArvoEvent[] }&gt;</code>, encapsulating all processing logic within a self-contained unit. This fundamental design choice enables handlers to operate independently, receiving all required context through event parameters and maintaining consistent behavior across different deployment environments.</p>
<p>The contract-based validation system ensures behavioral consistency regardless of where handlers execute, while the absence of shared state eliminates traditional scaling bottlenecks. This architectural approach provides natural support for both horizontal scaling through distribution across multiple compute nodes, and vertical scaling through resource allocation. The handlers maintain their operational integrity whether deployed in traditional cluster environments, container orchestration platforms, or serverless infrastructures.</p>
<p>This architecture allows development teams to concentrate on implementing business logic without being constrained by scaling considerations. Handlers written and tested in development environments can transition directly to handling production workloads across distributed instances. The event-driven communication model enables flexible deployment strategies - systems can begin as modular monolithic applications and evolve into distributed architectures by introducing message brokers. Service communication remains event-based throughout, with the broker implementation ranging from an in-memory array for simple scenarios to external message brokers for production deployments. Event coordination between services can be managed through either choreography patterns or using the ArvoOrchestrator implementation provided by the <code>arvo-xstate</code> package, offering flexibility in system design and evolution.</p>
<h2 id="testing-event-handlers-in-arvo" class="tsd-anchor-link">Testing Event Handlers in Arvo<a href="#testing-event-handlers-in-arvo" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>Testing event handlers is a critical part of building reliable event-driven systems with Arvo. It provides several features that make testing handlers straightforward and effective.</p>
<h3 id="the-pattern" class="tsd-anchor-link">The <code>EventHandlerFactory</code> Pattern<a href="#the-pattern" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>The <code>EventHandlerFactory</code> is a function that creates an event handler. It takes the handler's dependencies as parameters, allowing them to be easily mocked or substituted in tests. This is a form of dependency injection.</p>
<pre><code class="typescript">interface HandlerDependencies {
  database: DatabaseClient;
  logger: Logger;
}

const userHandlerFactory: EventHandlerFactory<HandlerDependencies> = ({
  database,
  logger
}) => createArvoEventHandler({
  // Handler configuration...
});
</code><button type="button">Copy</button></pre>

<p>In tests, you can provide mocked versions of the dependencies:</p>
<pre><code class="typescript">const mockedDatabase = createMockDatabase();
const mockedLogger = createMockLogger();

const handler = userHandlerFactory({
  database: mockedDatabase, 
  logger: mockedLogger
});
</code><button type="button">Copy</button></pre>

<p>This allows you to test the handler in isolation, controlling its dependencies and asserting on how it interacts with them.</p>
<h3 id="consistent-handler-signature" class="tsd-anchor-link">Consistent Handler Signature<a href="#consistent-handler-signature" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>All Arvo event handlers have the same basic signature:</p>
<pre><code>ArvoEvent => Promise<{ events:ArvoEvent[] }>
</code><button>Copy</button></pre>

<p>They take an <code>ArvoEvent</code> as input and return a <code>Promise</code> that resolves to an array of <code>ArvoEvent</code>s. This consistency makes it easy to write tests for any handler.</p>
<p>A typical test would:</p>
<ol>
<li>Create an input <code>ArvoEvent</code></li>
<li>Pass it to the handler's <code>execute</code> method</li>
<li>Assert on the output events</li>
</ol>
<pre><code class="typescript">it('should create a user successfully', async () => {
  const userCreatedEvent = createArvoEventFactory(
	  userCreateContract.version('1.0.0')
  ).accepts({
    subject: 'test-subject',
    source: 'com.test.test',
    data: { name: 'John Doe' }
  });

  const outputEvents = await handler.execute(userCreatedEvent);
  
  expect(outputEvents).toHaveLength(1);
  expect(outputEvents[0].type).toBe('evt.user.created');
  expect(outputEvents[0].data.userId).toBeDefined();
});
</code><button type="button">Copy</button></pre>

<h3 id="contract-based-validation" class="tsd-anchor-link">Contract-Based Validation<a href="#contract-based-validation" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>Arvo handlers are bound to an <code>ArvoContract</code> that specifies the events they can accept and emit. This contract is automatically validated at runtime.</p>
<p>If a handler tries to emit an event that doesn't conform to its contract, Arvo will throw a <code>ContractViolation</code> error. You can test this behavior directly:</p>
<pre><code class="typescript">it('should throw ContractViolation if emitting invalid event', async () => {
  const inputEvent = createArvoEvent({
    type: 'com.user.create',
    data: { name: 'John Doe' }
    ...rest,
  });

  await expect(handler.execute(inputEvent)).rejects.toThrow(ContractViolation);
});
</code><button type="button">Copy</button></pre>

<p>This test ensures that the handler adheres to its contract, providing an additional layer of safety and testability.</p>
<h3 id="integration-testing" class="tsd-anchor-link">Integration Testing<a href="#integration-testing" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>Arvo's contract-based design and use of the <code>ArvoEventFactory</code> pattern enable robust integration testing without needing to write extensive test code. The <code>ArvoContract</code> serves as a single source of truth that all services share, providing a clear specification of each service's expected behavior and interactions. Since inter-service communication must strictly adhere to the contract via <code>ArvoEvent</code>s, integration testing becomes more focused on verifying that events flow correctly through the system as a whole, rather than exhaustively testing every possible interaction between services. This contract-driven approach catches many potential integration issues at the contract level, reducing the surface area that needs to be covered by traditional integration tests. As a result, integration testing in Arvo can concentrate on high-level event flows and key scenarios, confident that the contract enforcement will maintain the agreed-upon interfaces between services.</p>
<h2 id="conclusion" class="tsd-anchor-link">Conclusion<a href="#conclusion" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>Arvo is a TypeScript framework designed to make building reliable, evolvable event-driven systems easier. It does this through:</p>
<ol>
<li><strong>Contract-first development</strong>: Service interfaces are defined upfront in ArvoContracts. These aren't just documentation, but are actively enforced in the code.</li>
<li><strong>Strong typing</strong>: Leveraging TypeScript allows for compile-time checks of event payloads against the contracts.</li>
<li><strong>Versioned contracts</strong>: Each version of a contract is treated as an independent interface. This allows services to evolve without breaking consumers.</li>
<li><strong>EventHandlerFactory pattern</strong>: A consistent way to create event handlers, injecting dependencies. Enables easier testing.</li>
<li><strong>Built-in error handling</strong>: Errors are automatically converted to system events or thrown as violations. Reduces boilerplate.</li>
<li><strong>Observability</strong>: Integration with OpenTelemetry for tracing and logToSpan utility for logging. Visibility into complex flows.</li>
<li><strong>Scalability</strong>: The functional handler design (ArvoEvent in, array of ArvoEvents out) allows horizontal and vertical scaling.</li>
</ol>
<p>The key idea is that by making service contracts first-class citizens and providing a structured way to create and evolve event-driven services, Arvo helps tame the complexity inherent in distributed systems development. While it makes trade-offs (like the additional code for versioned handlers), these are designed to prioritise maintainability and reliability over raw conciseness.</p>
<p>Of course, Arvo isn't a silver bullet - it's one opinionated approach to the challenges of event-driven architectures. But by learning from the history of SOA and more recent serverless trends, it attempts to provide a pragmatic, TypeScript-native framework for building the next generation of evolvable systems.</p>
<h2 id="appendix" class="tsd-anchor-link">Appendix<a href="#appendix" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><ul>
<li>For an indepth view of the functioning and execution of the ArvoEventHandler, please refer to the <a href="https://github.com/SaadAhmad123/arvo-event-handler/blob/main/src/ArvoEventHandler/ExecutionDiagrams.md">exection diagrams</a> of the <code>.execute</code> method.</li>
<li>Reade more about the <code>ArvoContract</code> in the <code>arvo-core</code> <a href="https://saadahmad123.github.io/arvo-core/documents/ArvoContract.html">documentation</a>.</li>
</ul>
</div></div><div class="col-sidebar"><div class="page-menu"><div class="tsd-navigation settings"><details class="tsd-accordion"><summary class="tsd-accordion-summary"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" aria-hidden="true"><use href="../assets/icons.svg#icon-chevronDown"></use></svg><h3>theme_settings</h3></summary><div class="tsd-accordion-details"><div class="tsd-filter-visibility"><span class="settings-label">theme_member_visibility</span><ul id="tsd-filter-options"><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-protected" name="protected"/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>flag_protected</span></label></li><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-inherited" name="inherited" checked/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>flag_inherited</span></label></li><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-external" name="external"/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>flag_external</span></label></li></ul></div><div class="tsd-theme-toggle"><label class="settings-label" for="tsd-theme">theme_theme</label><select id="tsd-theme"><option value="os">theme_os</option><option value="light">theme_light</option><option value="dark">theme_dark</option></select></div></div></details></div><details open class="tsd-accordion tsd-page-navigation"><summary class="tsd-accordion-summary"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" aria-hidden="true"><use href="../assets/icons.svg#icon-chevronDown"></use></svg><h3>theme_on_this_page</h3></summary><div class="tsd-accordion-details"><a href="#arvoeventhandler-implementation-of-a-reliable-event-driven-system"><span>Arvo<wbr/>Event<wbr/>Handler -<wbr/> <wbr/>Implementation of a <wbr/>Reliable <wbr/>Event-<wbr/>Driven <wbr/>System</span></a><a href="#getting-started-with"><span>Getting <wbr/>Started with </span></a><ul><li><a href="#your-first-event-handler"><span>Your <wbr/>First <wbr/>Event <wbr/>Handler</span></a></li><li><ul><li><a href="#step-1-set-up-your-contract-and-dependencies"><span>Step 1: <wbr/>Set <wbr/>Up <wbr/>Your <wbr/>Contract and <wbr/>Dependencies</span></a></li><li><a href="#step-2-create-your-event-handler"><span>Step 2: <wbr/>Create <wbr/>Your <wbr/>Event <wbr/>Handler</span></a></li><li><a href="#step-3-put-it-all-together"><span>Step 3: <wbr/>Put <wbr/>It <wbr/>All <wbr/>Together</span></a></li><li><a href="#step-4-run-your-service"><span>Step 4: <wbr/>Run <wbr/>Your <wbr/>Service</span></a></li></ul></li><li><a href="#advanced-patterns"><span>Advanced <wbr/>Patterns</span></a></li><li><ul><li><a href="#handling-multiple-versions"><span>Handling <wbr/>Multiple <wbr/>Versions</span></a></li><li><a href="#error-handling-strategy"><span>Error <wbr/>Handling <wbr/>Strategy</span></a></li><li><a href="#testing-your-handler"><span>Testing <wbr/>Your <wbr/>Handler</span></a></li></ul></li><li><a href="#whats-next"><span>What&#39;s <wbr/>Next?</span></a></li><li><a href="#principles-of-reliable-event-driven-systems"><span>Principles of <wbr/>Reliable <wbr/>Event-<wbr/>Driven <wbr/>Systems</span></a></li><li><a href="#contract-first-development-in-typescript"><span>Contract-<wbr/>First <wbr/>Development in <wbr/>Type<wbr/>Script</span></a></li><li><a href="#implementing-your-first-arvo-service"><span>Implementing <wbr/>Your <wbr/>First <wbr/>Arvo <wbr/>Service</span></a></li><li><ul><li><a href="#the-factory-pattern-"><span>The factory pattern -<wbr/> </span></a></li><li><a href="#anatomy-of-a-handler-function"><span>Anatomy of a handler function</span></a></li><li><a href="#logging-mechanism"><span>Logging <wbr/>Mechanism</span></a></li></ul></li><li><a href="#managing-service-evolution-through-contracts"><span>Managing <wbr/>Service <wbr/>Evolution <wbr/>Through <wbr/>Contracts</span></a></li><li><a href="#event-processing-and-execution-flow"><span>Event <wbr/>Processing and <wbr/>Execution <wbr/>Flow</span></a></li><li><ul><li><a href="#what-happens-here"><span>What <wbr/>Happens <wbr/>Here?</span></a></li><li><a href="#understanding-the-handler-interface"><span>Understanding the <wbr/>Handler <wbr/>Interface</span></a></li></ul></li><li><a href="#error-handling"><span>Error <wbr/>Handling</span></a></li><li><ul><li><a href="#system-error-events"><span>System <wbr/>Error <wbr/>Events</span></a></li><li><a href="#violations"><span>Violations</span></a></li><li><ul><li><a href="#configviolation"><span>Config<wbr/>Violation</span></a></li><li><a href="#contractviolation"><span>Contract<wbr/>Violation</span></a></li><li><a href="#executionviolation"><span>Execution<wbr/>Violation</span></a></li></ul></li></ul></li><li><a href="#a-note-on-contract-validation-performance"><span>A <wbr/>Note on <wbr/>Contract <wbr/>Validation <wbr/>Performance</span></a></li><li><a href="#multi-domain-event-broadcasting"><span>Multi-<wbr/>Domain <wbr/>Event <wbr/>Broadcasting</span></a></li><li><ul><li><ul><li><a href="#system-error-event-broadcasting"><span>System <wbr/>Error <wbr/>Event <wbr/>Broadcasting</span></a></li></ul></li><li><a href="#guiding-principal-for"><span>Guiding principal for </span></a></li><li><a href="#domain-broadcasting-pattern"><span>Domain broadcasting pattern</span></a></li><li><ul><li><a href="#step-1-update-your-event-handler"><span>Step 1: <wbr/>Update <wbr/>Your <wbr/>Event <wbr/>Handler</span></a></li><li><a href="#step-2-domain-broadcasting-examples"><span>Step 2: <wbr/>Domain <wbr/>Broadcasting <wbr/>Examples</span></a></li><li><a href="#understanding-domain-broadcasting-patterns"><span>Understanding <wbr/>Domain <wbr/>Broadcasting <wbr/>Patterns</span></a></li></ul></li></ul></li><li><a href="#event-handler-scaling"><span>Event <wbr/>Handler <wbr/>Scaling</span></a></li><li><a href="#testing-event-handlers-in-arvo"><span>Testing <wbr/>Event <wbr/>Handlers in <wbr/>Arvo</span></a></li><li><ul><li><a href="#the-pattern"><span>The  <wbr/>Pattern</span></a></li><li><a href="#consistent-handler-signature"><span>Consistent <wbr/>Handler <wbr/>Signature</span></a></li><li><a href="#contract-based-validation"><span>Contract-<wbr/>Based <wbr/>Validation</span></a></li><li><a href="#integration-testing"><span>Integration <wbr/>Testing</span></a></li></ul></li><li><a href="#conclusion"><span>Conclusion</span></a></li><li><a href="#appendix"><span>Appendix</span></a></li></ul></div></details></div><div class="site-menu"><nav class="tsd-navigation"><a href="../modules.html">arvo-event-handler</a><ul class="tsd-small-nested-navigation" id="tsd-nav-container"><li>theme_loading</li></ul></nav></div></div></div><footer><p class="tsd-generator">Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a> with <a href="https://github.com/JulianWowra/typedoc-github-theme" target="_blank">typedoc-github-theme</a></p></footer><div class="overlay"></div></body></html>
